/*
Jenkinsfile template for use in a multibranch pipeline
 */

def getAgentLabel(platform) {
  switch (platform) {
    case 'linux-x86_64-musl':
    case 'linux-x86_64-glibc':
      return 'small-node-c7'
    case 'linux-aarch64-musl':
    case 'linux-aarch64-glibc':
      return 'small-node-aarch64'
    case 'macos-x86_64':
      return 'mac_x86'
    case 'macos-aarch64':
      return 'mac_m1'
    case 'windows-x86_64':
      return 'windows-build-vs2022'
    case 'windows-i686':
      return 'windows-build-vs2022'
    case 'windows-aarch64':
      return 'small-node-c7'
    case 'aix-ppc64':
      return 'small-node-c7'
    default:
      error "Unsupported platform: ${platform}"
  }
}

def getDockerfile(platform) {
  switch (platform) {
    case 'linux-x86_64-musl':
    case 'linux-aarch64-musl':
      return 'Dockerfile.alpine'
    case 'linux-x86_64-glibc':
    case 'linux-aarch64-glibc':
      return 'Dockerfile.rocky'
    case 'windows-aarch64':
      return 'Dockerfile.xwin'
    default:
      return ''
  }
}

def needsDocker(platform) {
  return getDockerfile(platform) != ''
}

def platform_architecture(platform) {
  return platform.split('-')[1]
}

def platform_os(platform) {
  return platform.split('-')[0]
}

def platform_target(platform) {
  switch (platform) {
    case 'linux-x86_64-glibc':
      return 'x86_64-unknown-linux-gnu'
    case 'linux-aarch64-glibc':
      return 'aarch64-unknown-linux-gnu'
    case 'linux-x86_64-musl':
      return 'x86_64-unknown-linux-musl'
    case 'linux-aarch64-musl':
      return 'aarch64-unknown-linux-musl'
    case 'windows-aarch64':
      return 'aarch64-pc-windows-msvc'
    case 'windows-x86_64':
      return 'x86_64-pc-windows-msvc'
    case 'windows-i686':
      return 'i686-pc-windows-msvc'
    case 'macos-x86_64':
      return 'x86_64-apple-darwin'
    case 'macos-aarch64':
      return 'aarch64-apple-darwin'
    case 'aix-ppc64':
      return 'powerpc64-ibm-aix'
    default:
      error "Unsupported platform: ${platform}"
  }
}

def run_aix_command(command) {
  sshagent (credentials: ['aix-ssh-key']) {
    sh """
      |ssh ${AIX_USER}@${AIX_HOST} 'bash -s' <<EOF
      |  cd ${AIX_REPO_PATH}
      |  ${command}
      |EOF
    """.stripMargin()
  }
}

def setupRust(platform) {
  // Rust should be already installed on AIX
  if (platform_os(platform) == 'aix') {
    return
  }

  if (platform_os(platform) == 'windows' && platform != 'windows-aarch64') {
    bat """
      rustc --version || (
        echo Installing Rust...
        curl -L -sSf https://win.rustup.rs/x86_64 -o rustup-init.exe
        rustup-init.exe -y
        del rustup-init.exe
      )
      set PATH=%PATH%;%USERPROFILE%\\.cargo\\bin
      rustc --version
      cargo --version
      rustup target add ${platform_target(platform)}
    """.stripMargin()
    return
  }

  sh """
    whoami
    env
    if command -v rustc >/dev/null 2>&1; then
      rustup update stable
    else
      curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
      source $HOME/.cargo/env
    fi
    rustc --version
    cargo --version
    rustup target add ${platform_target(platform)}
  """.stripMargin()
}


def run_cargo_command(platform, command) {
  if (platform_os(platform) == 'aix') {
    run_aix_command("cargo ${command}")
    return
  }

  if (platform == 'windows-aarch64') {
    sh """
      cargo xwin ${command}
    """
    return
  }

  if (platform_os(platform) == 'windows') {
    bat """
      set PATH=%PATH%;%USERPROFILE%\\.cargo\\bin
      cargo ${command}
    """
    return
  }

  sh """
    cargo ${command}
  """
}

def checkout_repo() {
  checkout scm

  if (platform_os(platform) == 'aix') {
    sshagent (credentials: ['aix-ssh-key']) {
      sh """
        ssh ${AIX_USER}@${AIX_HOST} "mkdir -p ${AIX_REPO_PATH}"
        scp -r \$(pwd)/* ${AIX_USER}@${AIX_HOST}:${AIX_REPO_PATH}
      """
    }
  }
}

def cleanup() {
  if (platform_os(platform) == 'aix') {
    run_aix_command("""
      cd /home/jenkins
      rm -rf ${AIX_REPO_PATH}
    """)
  }
}

def uploadMinicorePackage(platform) {
  if (platform_os(platform) == 'aix') {
    run_aix_command("""
      set -x
      export PLATFORM=${platform}
      export COMMIT_SHA=${GIT_COMMIT}
      ./scripts/package_minicore.sh
    """)
    sshagent (credentials: ['aix-ssh-key']) {
      sh """
        source ./scripts/version.sh
        mkdir -p build
        export PLATFORM=${platform}
        export COMMIT_SHA=${GIT_COMMIT}
        scp -r ${AIX_USER}@${AIX_HOST}:${AIX_REPO_PATH}/build/sf_mini_core_\${PLATFORM}_\${VERSION}_SNAPSHOT_\${COMMIT_SHA}.tar.gz build/
        ./scripts/upload_minicore.sh
      """
    }
    return
  }

  if (platform_os(platform) == 'windows' && platform != 'windows-aarch64') {
    bat """
      set PATH=%PATH%;%USERPROFILE%\\.cargo\\bin
      set PLATFORM=${platform}
      set COMMIT_SHA=${GIT_COMMIT}
      call scripts\\package_minicore.bat
      call scripts\\upload_minicore.bat
    """
    return
  }

  sh """
    export PLATFORM=${platform}
    export COMMIT_SHA=${GIT_COMMIT}
    ./scripts/package_minicore.sh
    ./scripts/upload_minicore.sh
  """
}

pipeline {
  //Various labels available: https://snowflakecomputing.atlassian.net/wiki/spaces/EN/pages/2443215263/Agent+labels+in+jenkins
  agent none
  options { timestamps()
            disableResume() //REQUIRED SECTION - We must use this property, else PRs can get in stuck state for any controller restart
            buildDiscarder(logRotator(daysToKeepStr: '5', numToKeepStr: '50')) // REQUIRED SECTION - retention policy must be set
            timeout(time: 1, unit: 'HOURS') // REQUIRED SECTION - timeout must be set
          }
  triggers {
    cron(env.BRANCH_NAME == 'main' ? 'H H/6 * * *' : '')
  }
  stages {
        stage('Build Matrix') {
          matrix {
            axes {
              axis {
                name 'PLATFORM'
                values 'linux-x86_64-musl', 'linux-aarch64-musl', 'linux-x86_64-glibc', 'linux-aarch64-glibc', 'windows-x86_64', 'windows-i686', 'windows-aarch64', 'macos-x86_64', 'macos-aarch64', 'aix-ppc64'
              }
            }
            environment {
              AIX_REPO_PATH = '/home/jenkins/universal-driver/${BRANCH_NAME}-${BUILD_NUMBER}'
              AIX_HOST = '40.143.95.16'
              AIX_USER = 'jenkins'
            }
            stages {
              stage('Docker Build') {
                when {
                  beforeAgent true
                  expression { needsDocker(PLATFORM) }
                }
                agent {
                  dockerfile {
                    filename getDockerfile(PLATFORM)
                    dir 'ci'
                    args '-u root --privileged'
                    label getAgentLabel(PLATFORM)
                    reuseNode true
                  }
                }
                stages {
                  stage('checkout (docker)') {
                    steps {
                      checkout scm
                    }
                  }
                  stage('setup rust (docker)') {
                    steps {
                      setupRust(PLATFORM)
                    }
                  }
                  stage('build (docker)') {
                    steps {
                      run_cargo_command(PLATFORM, "build --package sf_mini_core --target ${platform_target(PLATFORM)}")
                    }
                  }
                  stage('test (docker)') {
                    steps {
                      run_cargo_command(PLATFORM, 'test --package sf_mini_core')
                    }
                  }
                  stage('upload minicore package (docker)') {
                    steps {
                      withCredentials([
                        usernamePassword(
                          usernameVariable: 'AWS_ACCESS_KEY_ID',
                          passwordVariable: 'AWS_SECRET_ACCESS_KEY',
                          credentialsId: '063fc85b-62a6-4181-9d72-873b43488411'
                        )
                      ]) {
                        uploadMinicorePackage(PLATFORM)
                      }
                    }
                  }
                }
              }
              
              stage('Node Build') {
                when {
                  beforeAgent true
                  expression { !needsDocker(PLATFORM) }
                }
                agent {
                  label getAgentLabel(PLATFORM)
                }
                stages {
                  stage('checkout (node)') {
                    steps {
                      checkout_repo()
                    }
                  }
                  stage('setup rust (node)') {
                    steps {
                      setupRust(PLATFORM)
                    }
                  }
                  stage('build (node)') {
                    steps {
                      run_cargo_command(PLATFORM, "build --package sf_mini_core --target ${platform_target(PLATFORM)}")
                    }
                  }
                  stage('test (node)') {
                    steps {
                      run_cargo_command(PLATFORM, 'test --package sf_mini_core')
                    }
                  }
                  stage('upload minicore package (node)') {
                    steps {
                      withCredentials([
                        usernamePassword(
                          usernameVariable: 'AWS_ACCESS_KEY_ID',
                          passwordVariable: 'AWS_SECRET_ACCESS_KEY',
                          credentialsId: '063fc85b-62a6-4181-9d72-873b43488411'
                        )
                      ]) {
                        uploadMinicorePackage(PLATFORM)
                      }
                    }
                  }
                }
                post {
                  always {
                    cleanup()
                  }
                }
              }
            }
          }
        }
  } 
}
