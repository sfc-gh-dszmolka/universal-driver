// Autogenerated by Thrift Compiler (0.22.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StatusCode(pub i32);

impl StatusCode {
  pub const OK: StatusCode = StatusCode(0);
  pub const AUTHENTICATION_ERROR: StatusCode = StatusCode(1);
  pub const NOT_IMPLEMENTED: StatusCode = StatusCode(2);
  pub const NOT_FOUND: StatusCode = StatusCode(3);
  pub const ALREADY_EXISTS: StatusCode = StatusCode(4);
  pub const INVALID_ARGUMENT: StatusCode = StatusCode(5);
  pub const INVALID_STATE: StatusCode = StatusCode(6);
  pub const INVALID_DATA: StatusCode = StatusCode(7);
  pub const IO: StatusCode = StatusCode(8);
  pub const CANCELLED: StatusCode = StatusCode(9);
  pub const UNAUTHENTICATED: StatusCode = StatusCode(10);
  pub const UNAUTHORIZED: StatusCode = StatusCode(11);
  pub const GENERIC_ERROR: StatusCode = StatusCode(12);
  pub const INTERNAL_ERROR: StatusCode = StatusCode(13);
  pub const MISSING_PARAMETER: StatusCode = StatusCode(14);
  pub const INVALID_PARAMETER_VALUE: StatusCode = StatusCode(15);
  pub const LOGIN_ERROR: StatusCode = StatusCode(16);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::OK,
    Self::AUTHENTICATION_ERROR,
    Self::NOT_IMPLEMENTED,
    Self::NOT_FOUND,
    Self::ALREADY_EXISTS,
    Self::INVALID_ARGUMENT,
    Self::INVALID_STATE,
    Self::INVALID_DATA,
    Self::IO,
    Self::CANCELLED,
    Self::UNAUTHENTICATED,
    Self::UNAUTHORIZED,
    Self::GENERIC_ERROR,
    Self::INTERNAL_ERROR,
    Self::MISSING_PARAMETER,
    Self::INVALID_PARAMETER_VALUE,
    Self::LOGIN_ERROR,
  ];
}

impl TSerializable for StatusCode {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<StatusCode> {
    let enum_value = i_prot.read_i32()?;
    Ok(StatusCode::from(enum_value))
  }
}

impl From<i32> for StatusCode {
  fn from(i: i32) -> Self {
    match i {
      0 => StatusCode::OK,
      1 => StatusCode::AUTHENTICATION_ERROR,
      2 => StatusCode::NOT_IMPLEMENTED,
      3 => StatusCode::NOT_FOUND,
      4 => StatusCode::ALREADY_EXISTS,
      5 => StatusCode::INVALID_ARGUMENT,
      6 => StatusCode::INVALID_STATE,
      7 => StatusCode::INVALID_DATA,
      8 => StatusCode::IO,
      9 => StatusCode::CANCELLED,
      10 => StatusCode::UNAUTHENTICATED,
      11 => StatusCode::UNAUTHORIZED,
      12 => StatusCode::GENERIC_ERROR,
      13 => StatusCode::INTERNAL_ERROR,
      14 => StatusCode::MISSING_PARAMETER,
      15 => StatusCode::INVALID_PARAMETER_VALUE,
      16 => StatusCode::LOGIN_ERROR,
      _ => StatusCode(i)
    }
  }
}

impl From<&i32> for StatusCode {
  fn from(i: &i32) -> Self {
    StatusCode::from(*i)
  }
}

impl From<StatusCode> for i32 {
  fn from(e: StatusCode) -> i32 {
    e.0
  }
}

impl From<&StatusCode> for i32 {
  fn from(e: &StatusCode) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct InfoCode(pub i32);

impl InfoCode {
  pub const VENDOR_NAME: InfoCode = InfoCode(0);
  pub const VENDOR_VERSION: InfoCode = InfoCode(1);
  pub const VENDOR_ARROW_VERSION: InfoCode = InfoCode(2);
  pub const VENDOR_SQL: InfoCode = InfoCode(100);
  pub const VENDOR_SUBSTRAIT: InfoCode = InfoCode(101);
  pub const VENDOR_SUBSTRAIT_MIN_VERSION: InfoCode = InfoCode(102);
  pub const VENDOR_SUBSTRAIT_MAX_VERSION: InfoCode = InfoCode(103);
  pub const DRIVER_NAME: InfoCode = InfoCode(200);
  pub const DRIVER_VERSION: InfoCode = InfoCode(201);
  pub const DRIVER_ARROW_VERSION: InfoCode = InfoCode(202);
  pub const DRIVER_ADBC_VERSION: InfoCode = InfoCode(203);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::VENDOR_NAME,
    Self::VENDOR_VERSION,
    Self::VENDOR_ARROW_VERSION,
    Self::VENDOR_SQL,
    Self::VENDOR_SUBSTRAIT,
    Self::VENDOR_SUBSTRAIT_MIN_VERSION,
    Self::VENDOR_SUBSTRAIT_MAX_VERSION,
    Self::DRIVER_NAME,
    Self::DRIVER_VERSION,
    Self::DRIVER_ARROW_VERSION,
    Self::DRIVER_ADBC_VERSION,
  ];
}

impl TSerializable for InfoCode {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<InfoCode> {
    let enum_value = i_prot.read_i32()?;
    Ok(InfoCode::from(enum_value))
  }
}

impl From<i32> for InfoCode {
  fn from(i: i32) -> Self {
    match i {
      0 => InfoCode::VENDOR_NAME,
      1 => InfoCode::VENDOR_VERSION,
      2 => InfoCode::VENDOR_ARROW_VERSION,
      100 => InfoCode::VENDOR_SQL,
      101 => InfoCode::VENDOR_SUBSTRAIT,
      102 => InfoCode::VENDOR_SUBSTRAIT_MIN_VERSION,
      103 => InfoCode::VENDOR_SUBSTRAIT_MAX_VERSION,
      200 => InfoCode::DRIVER_NAME,
      201 => InfoCode::DRIVER_VERSION,
      202 => InfoCode::DRIVER_ARROW_VERSION,
      203 => InfoCode::DRIVER_ADBC_VERSION,
      _ => InfoCode(i)
    }
  }
}

impl From<&i32> for InfoCode {
  fn from(i: &i32) -> Self {
    InfoCode::from(*i)
  }
}

impl From<InfoCode> for i32 {
  fn from(e: InfoCode) -> i32 {
    e.0
  }
}

impl From<&InfoCode> for i32 {
  fn from(e: &InfoCode) -> i32 {
    e.0
  }
}

//
// ErrorDetail
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ErrorDetail {
  pub key: String,
  pub value: String,
}

impl ErrorDetail {
  pub fn new(key: String, value: String) -> ErrorDetail {
    ErrorDetail {
      key,
      value,
    }
  }
}

impl TSerializable for ErrorDetail {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ErrorDetail> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ErrorDetail.key", &f_1)?;
    verify_required_field_exists("ErrorDetail.value", &f_2)?;
    let ret = ErrorDetail {
      key: f_1.expect("auto-generated code should have checked for presence of required fields"),
      value: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ErrorDetail");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 1))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 2))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AuthenticationError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AuthenticationError {
  pub detail: String,
}

impl AuthenticationError {
  pub fn new(detail: String) -> AuthenticationError {
    AuthenticationError {
      detail,
    }
  }
}

impl TSerializable for AuthenticationError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AuthenticationError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AuthenticationError.detail", &f_1)?;
    let ret = AuthenticationError {
      detail: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AuthenticationError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("detail", TType::String, 1))?;
    o_prot.write_string(&self.detail)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GenericError
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GenericError {
}

impl GenericError {
  pub fn new() -> GenericError {
    GenericError {}
  }
}

impl TSerializable for GenericError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GenericError> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GenericError {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GenericError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// InternalError
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct InternalError {
}

impl InternalError {
  pub fn new() -> InternalError {
    InternalError {}
  }
}

impl TSerializable for InternalError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<InternalError> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = InternalError {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("InternalError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// LoginError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct LoginError {
  pub message: String,
  pub code: i32,
}

impl LoginError {
  pub fn new(message: String, code: i32) -> LoginError {
    LoginError {
      message,
      code,
    }
  }
}

impl TSerializable for LoginError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LoginError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("LoginError.message", &f_1)?;
    verify_required_field_exists("LoginError.code", &f_2)?;
    let ret = LoginError {
      message: f_1.expect("auto-generated code should have checked for presence of required fields"),
      code: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("LoginError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::I32, 2))?;
    o_prot.write_i32(self.code)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MissingParameter
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MissingParameter {
  pub parameter: String,
}

impl MissingParameter {
  pub fn new(parameter: String) -> MissingParameter {
    MissingParameter {
      parameter,
    }
  }
}

impl TSerializable for MissingParameter {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MissingParameter> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("MissingParameter.parameter", &f_1)?;
    let ret = MissingParameter {
      parameter: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MissingParameter");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parameter", TType::String, 1))?;
    o_prot.write_string(&self.parameter)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// InvalidParameterValue
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct InvalidParameterValue {
  pub parameter: String,
  pub value: String,
  pub explanation: Option<String>,
}

impl InvalidParameterValue {
  pub fn new<F3>(parameter: String, value: String, explanation: F3) -> InvalidParameterValue where F3: Into<Option<String>> {
    InvalidParameterValue {
      parameter,
      value,
      explanation: explanation.into(),
    }
  }
}

impl TSerializable for InvalidParameterValue {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<InvalidParameterValue> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("InvalidParameterValue.parameter", &f_1)?;
    verify_required_field_exists("InvalidParameterValue.value", &f_2)?;
    let ret = InvalidParameterValue {
      parameter: f_1.expect("auto-generated code should have checked for presence of required fields"),
      value: f_2.expect("auto-generated code should have checked for presence of required fields"),
      explanation: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("InvalidParameterValue");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parameter", TType::String, 1))?;
    o_prot.write_string(&self.parameter)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 2))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.explanation {
      o_prot.write_field_begin(&TFieldIdentifier::new("explanation", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DriverError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum DriverError {
  AuthError(AuthenticationError),
  GenericError(GenericError),
  InternalError(InternalError),
  MissingParameter(MissingParameter),
  InvalidParameterValue(InvalidParameterValue),
  LoginError(LoginError),
}

impl TSerializable for DriverError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DriverError> {
    let mut ret: Option<DriverError> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AuthenticationError::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DriverError::AuthError(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = GenericError::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DriverError::GenericError(val));
          }
          received_field_count += 1;
        },
        3 => {
          let val = InternalError::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DriverError::InternalError(val));
          }
          received_field_count += 1;
        },
        4 => {
          let val = MissingParameter::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DriverError::MissingParameter(val));
          }
          received_field_count += 1;
        },
        5 => {
          let val = InvalidParameterValue::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DriverError::InvalidParameterValue(val));
          }
          received_field_count += 1;
        },
        6 => {
          let val = LoginError::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(DriverError::LoginError(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote DriverError"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote DriverError"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DriverError");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      DriverError::AuthError(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("authError", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      DriverError::GenericError(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("genericError", TType::Struct, 2))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      DriverError::InternalError(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("internalError", TType::Struct, 3))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      DriverError::MissingParameter(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("missingParameter", TType::Struct, 4))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      DriverError::InvalidParameterValue(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("invalidParameterValue", TType::Struct, 5))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      DriverError::LoginError(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("loginError", TType::Struct, 6))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DriverException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DriverException {
  pub message: String,
  pub status_code: StatusCode,
  pub error: DriverError,
  pub report: String,
}

impl DriverException {
  pub fn new(message: String, status_code: StatusCode, error: DriverError, report: String) -> DriverException {
    DriverException {
      message,
      status_code,
      error,
      report,
    }
  }
}

impl TSerializable for DriverException {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DriverException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<StatusCode> = None;
    let mut f_3: Option<DriverError> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = StatusCode::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = DriverError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DriverException.message", &f_1)?;
    verify_required_field_exists("DriverException.status_code", &f_2)?;
    verify_required_field_exists("DriverException.error", &f_3)?;
    verify_required_field_exists("DriverException.report", &f_4)?;
    let ret = DriverException {
      message: f_1.expect("auto-generated code should have checked for presence of required fields"),
      status_code: f_2.expect("auto-generated code should have checked for presence of required fields"),
      error: f_3.expect("auto-generated code should have checked for presence of required fields"),
      report: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DriverException");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status_code", TType::I32, 2))?;
    self.status_code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("error", TType::Struct, 3))?;
    self.error.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("report", TType::String, 4))?;
    o_prot.write_string(&self.report)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for DriverException {}

impl From<DriverException> for thrift::Error {
  fn from(e: DriverException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for DriverException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw DriverException")
  }
}

//
// ExecuteResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ExecuteResult {
  pub stream: Box<ArrowArrayStreamPtr>,
  pub rows_affected: i64,
}

impl ExecuteResult {
  pub fn new(stream: Box<ArrowArrayStreamPtr>, rows_affected: i64) -> ExecuteResult {
    ExecuteResult {
      stream,
      rows_affected,
    }
  }
}

impl TSerializable for ExecuteResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExecuteResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Box<ArrowArrayStreamPtr>> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Box::new(ArrowArrayStreamPtr::read_from_in_protocol(i_prot)?);
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ExecuteResult.stream", &f_1)?;
    verify_required_field_exists("ExecuteResult.rows_affected", &f_2)?;
    let ret = ExecuteResult {
      stream: f_1.expect("auto-generated code should have checked for presence of required fields"),
      rows_affected: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ExecuteResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stream", TType::Struct, 1))?;
    self.stream.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rows_affected", TType::I64, 2))?;
    o_prot.write_i64(self.rows_affected)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PartitionedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PartitionedResult {
  pub schema: i64,
  pub partitions: Vec<Vec<u8>>,
  pub rows_affected: i64,
}

impl PartitionedResult {
  pub fn new(schema: i64, partitions: Vec<Vec<u8>>, rows_affected: i64) -> PartitionedResult {
    PartitionedResult {
      schema,
      partitions,
      rows_affected,
    }
  }
}

impl TSerializable for PartitionedResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PartitionedResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<Vec<u8>>> = None;
    let mut f_3: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = i_prot.read_bytes()?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PartitionedResult.schema", &f_1)?;
    verify_required_field_exists("PartitionedResult.partitions", &f_2)?;
    verify_required_field_exists("PartitionedResult.rows_affected", &f_3)?;
    let ret = PartitionedResult {
      schema: f_1.expect("auto-generated code should have checked for presence of required fields"),
      partitions: f_2.expect("auto-generated code should have checked for presence of required fields"),
      rows_affected: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PartitionedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("schema", TType::I64, 1))?;
    o_prot.write_i64(self.schema)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partitions", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.partitions.len() as i32))?;
    for e in &self.partitions {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rows_affected", TType::I64, 3))?;
    o_prot.write_i64(self.rows_affected)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseHandle
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DatabaseHandle {
  pub id: i64,
  pub magic: i64,
}

impl DatabaseHandle {
  pub fn new(id: i64, magic: i64) -> DatabaseHandle {
    DatabaseHandle {
      id,
      magic,
    }
  }
}

impl TSerializable for DatabaseHandle {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseHandle> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseHandle.id", &f_1)?;
    verify_required_field_exists("DatabaseHandle.magic", &f_2)?;
    let ret = DatabaseHandle {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      magic: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseHandle");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
    o_prot.write_i64(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("magic", TType::I64, 2))?;
    o_prot.write_i64(self.magic)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ConnectionHandle
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ConnectionHandle {
  pub id: i64,
  pub magic: i64,
}

impl ConnectionHandle {
  pub fn new(id: i64, magic: i64) -> ConnectionHandle {
    ConnectionHandle {
      id,
      magic,
    }
  }
}

impl TSerializable for ConnectionHandle {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ConnectionHandle> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ConnectionHandle.id", &f_1)?;
    verify_required_field_exists("ConnectionHandle.magic", &f_2)?;
    let ret = ConnectionHandle {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      magic: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ConnectionHandle");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
    o_prot.write_i64(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("magic", TType::I64, 2))?;
    o_prot.write_i64(self.magic)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// StatementHandle
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StatementHandle {
  pub id: i64,
  pub magic: i64,
}

impl StatementHandle {
  pub fn new(id: i64, magic: i64) -> StatementHandle {
    StatementHandle {
      id,
      magic,
    }
  }
}

impl TSerializable for StatementHandle {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<StatementHandle> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("StatementHandle.id", &f_1)?;
    verify_required_field_exists("StatementHandle.magic", &f_2)?;
    let ret = StatementHandle {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      magic: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("StatementHandle");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
    o_prot.write_i64(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("magic", TType::I64, 2))?;
    o_prot.write_i64(self.magic)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ArrowArrayStreamPtr
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ArrowArrayStreamPtr {
  pub value: Vec<u8>,
}

impl ArrowArrayStreamPtr {
  pub fn new(value: Vec<u8>) -> ArrowArrayStreamPtr {
    ArrowArrayStreamPtr {
      value,
    }
  }
}

impl TSerializable for ArrowArrayStreamPtr {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ArrowArrayStreamPtr> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ArrowArrayStreamPtr.value", &f_1)?;
    let ret = ArrowArrayStreamPtr {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ArrowArrayStreamPtr");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
    o_prot.write_bytes(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ArrowSchemaPtr
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ArrowSchemaPtr {
  pub value: Vec<u8>,
}

impl ArrowSchemaPtr {
  pub fn new(value: Vec<u8>) -> ArrowSchemaPtr {
    ArrowSchemaPtr {
      value,
    }
  }
}

impl TSerializable for ArrowSchemaPtr {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ArrowSchemaPtr> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ArrowSchemaPtr.value", &f_1)?;
    let ret = ArrowSchemaPtr {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ArrowSchemaPtr");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
    o_prot.write_bytes(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ArrowArrayPtr
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ArrowArrayPtr {
  pub value: Vec<u8>,
}

impl ArrowArrayPtr {
  pub fn new(value: Vec<u8>) -> ArrowArrayPtr {
    ArrowArrayPtr {
      value,
    }
  }
}

impl TSerializable for ArrowArrayPtr {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ArrowArrayPtr> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ArrowArrayPtr.value", &f_1)?;
    let ret = ArrowArrayPtr {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ArrowArrayPtr");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
    o_prot.write_bytes(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriver service client
//

pub trait TDatabaseDriverSyncClient {
  /// Create a new, uninitialized database object.
  /// Corresponds to AdbcDatabaseNew.
  /// @return An opaque handle to the server-side database object.
  fn database_new(&mut self) -> thrift::Result<DatabaseHandle>;
  /// Set a string-valued option for a database.
  /// Corresponds to AdbcDatabaseSetOption.
  fn database_set_option_string(&mut self, db_handle: DatabaseHandle, key: String, value: String) -> thrift::Result<()>;
  /// Set a byte-valued option for a database.
  /// Corresponds to AdbcDatabaseSetOptionBytes.
  fn database_set_option_bytes(&mut self, db_handle: DatabaseHandle, key: String, value: Vec<u8>) -> thrift::Result<()>;
  /// Set an integer-valued option for a database.
  /// Corresponds to AdbcDatabaseSetOptionInt.
  fn database_set_option_int(&mut self, db_handle: DatabaseHandle, key: String, value: i64) -> thrift::Result<()>;
  /// Set a double-valued option for a database.
  /// Corresponds to AdbcDatabaseSetOptionDouble.
  fn database_set_option_double(&mut self, db_handle: DatabaseHandle, key: String, value: OrderedFloat<f64>) -> thrift::Result<()>;
  /// Finalize database initialization.
  /// Corresponds to AdbcDatabaseInit.
  fn database_init(&mut self, db_handle: DatabaseHandle) -> thrift::Result<()>;
  /// Release the database object and its resources. The handle is invalidated.
  /// Corresponds to AdbcDatabaseRelease.
  fn database_release(&mut self, db_handle: DatabaseHandle) -> thrift::Result<()>;
  /// Create a new, uninitialized connection object.
  /// Corresponds to AdbcConnectionNew.
  /// @return An opaque handle to the server-side connection object.
  fn connection_new(&mut self) -> thrift::Result<ConnectionHandle>;
  /// Set a string-valued option for a connection.
  /// Corresponds to AdbcConnectionSetOption.
  fn connection_set_option_string(&mut self, conn_handle: ConnectionHandle, key: String, value: String) -> thrift::Result<()>;
  /// Set a byte-valued option for a connection.
  /// Corresponds to AdbcConnectionSetOptionBytes.
  fn connection_set_option_bytes(&mut self, conn_handle: ConnectionHandle, key: String, value: Vec<u8>) -> thrift::Result<()>;
  /// Set an integer-valued option for a connection.
  /// Corresponds to AdbcConnectionSetOptionInt.
  fn connection_set_option_int(&mut self, conn_handle: ConnectionHandle, key: String, value: i64) -> thrift::Result<()>;
  /// Set a double-valued option for a connection.
  /// Corresponds to AdbcConnectionSetOptionDouble.
  fn connection_set_option_double(&mut self, conn_handle: ConnectionHandle, key: String, value: OrderedFloat<f64>) -> thrift::Result<()>;
  /// Finalize connection initialization.
  /// Corresponds to AdbcConnectionInit.
  fn connection_init(&mut self, conn_handle: ConnectionHandle, db_handle: DatabaseHandle) -> thrift::Result<()>;
  /// Release the connection object and its resources. The handle is invalidated.
  /// Corresponds to AdbcConnectionRelease.
  fn connection_release(&mut self, conn_handle: ConnectionHandle) -> thrift::Result<()>;
  /// Get metadata about the database/driver.
  /// Corresponds to AdbcConnectionGetInfo.
  /// @param info_codes A list of codes for the metadata to retrieve. If null/empty, retrieve all.
  /// @return An Arrow IPC stream containing the metadata.
  fn connection_get_info(&mut self, conn_handle: ConnectionHandle, info_codes: Vec<InfoCode>) -> thrift::Result<Vec<u8>>;
  /// Get a hierarchical view of catalogs, DB schemas, tables, and columns.
  /// Corresponds to AdbcConnectionGetObjects.
  /// @return An Arrow IPC stream containing the metadata.
  fn connection_get_objects(&mut self, conn_handle: ConnectionHandle, depth: i32, catalog: String, db_schema: String, table_name: String, table_type: Vec<String>, column_name: String) -> thrift::Result<Vec<u8>>;
  /// Get the Arrow schema of a table.
  /// Corresponds to AdbcConnectionGetTableSchema.
  /// @return A serialized ArrowSchema in IPC format.
  fn connection_get_table_schema(&mut self, conn_handle: ConnectionHandle, catalog: String, db_schema: String, table_name: String) -> thrift::Result<Vec<u8>>;
  /// Get a list of table types in the database.
  /// Corresponds to AdbcConnectionGetTableTypes.
  /// @return An Arrow IPC stream containing the table types.
  fn connection_get_table_types(&mut self, conn_handle: ConnectionHandle) -> thrift::Result<Vec<u8>>;
  /// Commit any pending transactions.
  /// Corresponds to AdbcConnectionCommit.
  fn connection_commit(&mut self, conn_handle: ConnectionHandle) -> thrift::Result<()>;
  /// Roll back any pending transactions.
  /// Corresponds to AdbcConnectionRollback.
  fn connection_rollback(&mut self, conn_handle: ConnectionHandle) -> thrift::Result<()>;
  /// Create a new statement.
  /// Corresponds to AdbcStatementNew.
  /// @return An opaque handle to the server-side statement object.
  fn statement_new(&mut self, conn_handle: ConnectionHandle) -> thrift::Result<StatementHandle>;
  /// Release the statement object.
  /// Corresponds to AdbcStatementRelease.
  fn statement_release(&mut self, stmt_handle: StatementHandle) -> thrift::Result<()>;
  /// Set the SQL query to execute.
  /// Corresponds to AdbcStatementSetSqlQuery.
  fn statement_set_sql_query(&mut self, stmt_handle: StatementHandle, query: String) -> thrift::Result<()>;
  /// Set the Substrait plan to execute.
  /// Corresponds to AdbcStatementSetSubstraitPlan.
  fn statement_set_substrait_plan(&mut self, stmt_handle: StatementHandle, plan: Vec<u8>) -> thrift::Result<()>;
  /// Prepare a statement for execution.
  /// Corresponds to AdbcStatementPrepare.
  fn statement_prepare(&mut self, stmt_handle: StatementHandle) -> thrift::Result<()>;
  /// Set a string-valued option for a statement.
  /// Corresponds to AdbcStatementSetOption.
  fn statement_set_option_string(&mut self, stmt_handle: StatementHandle, key: String, value: String) -> thrift::Result<()>;
  /// Set a byte-valued option for a statement.
  /// Corresponds to AdbcStatementSetOptionBytes.
  fn statement_set_option_bytes(&mut self, stmt_handle: StatementHandle, key: String, value: Vec<u8>) -> thrift::Result<()>;
  /// Set an integer-valued option for a statement.
  /// Corresponds to AdbcStatementSetOptionInt.
  fn statement_set_option_int(&mut self, stmt_handle: StatementHandle, key: String, value: i64) -> thrift::Result<()>;
  /// Set a double-valued option for a statement.
  /// Corresponds to AdbcStatementSetOptionDouble.
  fn statement_set_option_double(&mut self, stmt_handle: StatementHandle, key: String, value: OrderedFloat<f64>) -> thrift::Result<()>;
  /// Get the schema for the parameters of a prepared statement.
  /// Corresponds to AdbcStatementGetParameterSchema.
  /// @return A serialized ArrowSchema in IPC format.
  fn statement_get_parameter_schema(&mut self, stmt_handle: StatementHandle) -> thrift::Result<ArrowSchemaPtr>;
  /// Bind a single batch of values to a prepared statement.
  /// Corresponds to AdbcStatementBind.
  /// @param values An Arrow RecordBatch serialized in IPC format.
  fn statement_bind(&mut self, stmt_handle: StatementHandle, schema: ArrowSchemaPtr, array: ArrowArrayPtr) -> thrift::Result<()>;
  /// Bind a stream of values to a statement (for bulk ingestion).
  /// Corresponds to AdbcStatementBindStream.
  /// @param stream An Arrow stream serialized in IPC format.
  fn statement_bind_stream(&mut self, stmt_handle: StatementHandle, stream: Vec<u8>) -> thrift::Result<()>;
  /// Execute a query or a statement with bound data.
  /// Corresponds to AdbcStatementExecuteQuery.
  /// @return An ExecuteResult struct containing the result stream and rows affected.
  fn statement_execute_query(&mut self, stmt_handle: StatementHandle) -> thrift::Result<ExecuteResult>;
  /// Execute a query and get a description of the result partitions.
  /// Corresponds to AdbcStatementExecutePartitions.
  /// @return A PartitionedResult struct containing schema and partition descriptors.
  fn statement_execute_partitions(&mut self, stmt_handle: StatementHandle) -> thrift::Result<PartitionedResult>;
  /// Read a single partition of a result set.
  /// Corresponds to AdbcConnectionReadPartition.
  /// @param partition_descriptor An opaque descriptor from statementExecutePartitions.
  /// @return An Arrow IPC stream for the requested partition.
  fn statement_read_partition(&mut self, stmt_handle: StatementHandle, partition_descriptor: Vec<u8>) -> thrift::Result<i64>;
}

pub trait TDatabaseDriverSyncClientMarker {}

pub struct DatabaseDriverSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> DatabaseDriverSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> DatabaseDriverSyncClient<IP, OP> {
    DatabaseDriverSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for DatabaseDriverSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TDatabaseDriverSyncClientMarker for DatabaseDriverSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TDatabaseDriverSyncClientMarker> TDatabaseDriverSyncClient for C {
  fn database_new(&mut self) -> thrift::Result<DatabaseHandle> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("databaseNew", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverDatabaseNewArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("databaseNew", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverDatabaseNewResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn database_set_option_string(&mut self, db_handle: DatabaseHandle, key: String, value: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("databaseSetOptionString", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverDatabaseSetOptionStringArgs { db_handle, key, value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("databaseSetOptionString", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverDatabaseSetOptionStringResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn database_set_option_bytes(&mut self, db_handle: DatabaseHandle, key: String, value: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("databaseSetOptionBytes", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverDatabaseSetOptionBytesArgs { db_handle, key, value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("databaseSetOptionBytes", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverDatabaseSetOptionBytesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn database_set_option_int(&mut self, db_handle: DatabaseHandle, key: String, value: i64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("databaseSetOptionInt", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverDatabaseSetOptionIntArgs { db_handle, key, value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("databaseSetOptionInt", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverDatabaseSetOptionIntResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn database_set_option_double(&mut self, db_handle: DatabaseHandle, key: String, value: OrderedFloat<f64>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("databaseSetOptionDouble", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverDatabaseSetOptionDoubleArgs { db_handle, key, value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("databaseSetOptionDouble", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverDatabaseSetOptionDoubleResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn database_init(&mut self, db_handle: DatabaseHandle) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("databaseInit", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverDatabaseInitArgs { db_handle };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("databaseInit", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverDatabaseInitResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn database_release(&mut self, db_handle: DatabaseHandle) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("databaseRelease", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverDatabaseReleaseArgs { db_handle };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("databaseRelease", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverDatabaseReleaseResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn connection_new(&mut self) -> thrift::Result<ConnectionHandle> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("connectionNew", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverConnectionNewArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("connectionNew", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverConnectionNewResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn connection_set_option_string(&mut self, conn_handle: ConnectionHandle, key: String, value: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("connectionSetOptionString", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverConnectionSetOptionStringArgs { conn_handle, key, value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("connectionSetOptionString", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverConnectionSetOptionStringResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn connection_set_option_bytes(&mut self, conn_handle: ConnectionHandle, key: String, value: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("connectionSetOptionBytes", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverConnectionSetOptionBytesArgs { conn_handle, key, value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("connectionSetOptionBytes", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverConnectionSetOptionBytesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn connection_set_option_int(&mut self, conn_handle: ConnectionHandle, key: String, value: i64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("connectionSetOptionInt", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverConnectionSetOptionIntArgs { conn_handle, key, value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("connectionSetOptionInt", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverConnectionSetOptionIntResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn connection_set_option_double(&mut self, conn_handle: ConnectionHandle, key: String, value: OrderedFloat<f64>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("connectionSetOptionDouble", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverConnectionSetOptionDoubleArgs { conn_handle, key, value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("connectionSetOptionDouble", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverConnectionSetOptionDoubleResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn connection_init(&mut self, conn_handle: ConnectionHandle, db_handle: DatabaseHandle) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("connectionInit", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverConnectionInitArgs { conn_handle, db_handle };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("connectionInit", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverConnectionInitResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn connection_release(&mut self, conn_handle: ConnectionHandle) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("connectionRelease", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverConnectionReleaseArgs { conn_handle };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("connectionRelease", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverConnectionReleaseResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn connection_get_info(&mut self, conn_handle: ConnectionHandle, info_codes: Vec<InfoCode>) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("connectionGetInfo", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverConnectionGetInfoArgs { conn_handle, info_codes };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("connectionGetInfo", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverConnectionGetInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn connection_get_objects(&mut self, conn_handle: ConnectionHandle, depth: i32, catalog: String, db_schema: String, table_name: String, table_type: Vec<String>, column_name: String) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("connectionGetObjects", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverConnectionGetObjectsArgs { conn_handle, depth, catalog, db_schema, table_name, table_type, column_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("connectionGetObjects", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverConnectionGetObjectsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn connection_get_table_schema(&mut self, conn_handle: ConnectionHandle, catalog: String, db_schema: String, table_name: String) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("connectionGetTableSchema", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverConnectionGetTableSchemaArgs { conn_handle, catalog, db_schema, table_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("connectionGetTableSchema", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverConnectionGetTableSchemaResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn connection_get_table_types(&mut self, conn_handle: ConnectionHandle) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("connectionGetTableTypes", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverConnectionGetTableTypesArgs { conn_handle };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("connectionGetTableTypes", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverConnectionGetTableTypesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn connection_commit(&mut self, conn_handle: ConnectionHandle) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("connectionCommit", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverConnectionCommitArgs { conn_handle };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("connectionCommit", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverConnectionCommitResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn connection_rollback(&mut self, conn_handle: ConnectionHandle) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("connectionRollback", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverConnectionRollbackArgs { conn_handle };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("connectionRollback", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverConnectionRollbackResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn statement_new(&mut self, conn_handle: ConnectionHandle) -> thrift::Result<StatementHandle> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("statementNew", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverStatementNewArgs { conn_handle };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("statementNew", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverStatementNewResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn statement_release(&mut self, stmt_handle: StatementHandle) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("statementRelease", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverStatementReleaseArgs { stmt_handle };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("statementRelease", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverStatementReleaseResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn statement_set_sql_query(&mut self, stmt_handle: StatementHandle, query: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("statementSetSqlQuery", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverStatementSetSqlQueryArgs { stmt_handle, query };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("statementSetSqlQuery", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverStatementSetSqlQueryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn statement_set_substrait_plan(&mut self, stmt_handle: StatementHandle, plan: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("statementSetSubstraitPlan", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverStatementSetSubstraitPlanArgs { stmt_handle, plan };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("statementSetSubstraitPlan", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverStatementSetSubstraitPlanResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn statement_prepare(&mut self, stmt_handle: StatementHandle) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("statementPrepare", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverStatementPrepareArgs { stmt_handle };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("statementPrepare", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverStatementPrepareResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn statement_set_option_string(&mut self, stmt_handle: StatementHandle, key: String, value: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("statementSetOptionString", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverStatementSetOptionStringArgs { stmt_handle, key, value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("statementSetOptionString", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverStatementSetOptionStringResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn statement_set_option_bytes(&mut self, stmt_handle: StatementHandle, key: String, value: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("statementSetOptionBytes", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverStatementSetOptionBytesArgs { stmt_handle, key, value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("statementSetOptionBytes", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverStatementSetOptionBytesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn statement_set_option_int(&mut self, stmt_handle: StatementHandle, key: String, value: i64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("statementSetOptionInt", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverStatementSetOptionIntArgs { stmt_handle, key, value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("statementSetOptionInt", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverStatementSetOptionIntResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn statement_set_option_double(&mut self, stmt_handle: StatementHandle, key: String, value: OrderedFloat<f64>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("statementSetOptionDouble", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverStatementSetOptionDoubleArgs { stmt_handle, key, value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("statementSetOptionDouble", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverStatementSetOptionDoubleResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn statement_get_parameter_schema(&mut self, stmt_handle: StatementHandle) -> thrift::Result<ArrowSchemaPtr> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("statementGetParameterSchema", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverStatementGetParameterSchemaArgs { stmt_handle };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("statementGetParameterSchema", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverStatementGetParameterSchemaResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn statement_bind(&mut self, stmt_handle: StatementHandle, schema: ArrowSchemaPtr, array: ArrowArrayPtr) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("statementBind", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverStatementBindArgs { stmt_handle, schema, array };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("statementBind", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverStatementBindResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn statement_bind_stream(&mut self, stmt_handle: StatementHandle, stream: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("statementBindStream", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverStatementBindStreamArgs { stmt_handle, stream };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("statementBindStream", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverStatementBindStreamResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn statement_execute_query(&mut self, stmt_handle: StatementHandle) -> thrift::Result<ExecuteResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("statementExecuteQuery", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverStatementExecuteQueryArgs { stmt_handle };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("statementExecuteQuery", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverStatementExecuteQueryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn statement_execute_partitions(&mut self, stmt_handle: StatementHandle) -> thrift::Result<PartitionedResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("statementExecutePartitions", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverStatementExecutePartitionsArgs { stmt_handle };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("statementExecutePartitions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverStatementExecutePartitionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn statement_read_partition(&mut self, stmt_handle: StatementHandle, partition_descriptor: Vec<u8>) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("statementReadPartition", TMessageType::Call, self.sequence_number());
        let call_args = DatabaseDriverStatementReadPartitionArgs { stmt_handle, partition_descriptor };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("statementReadPartition", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DatabaseDriverStatementReadPartitionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// DatabaseDriver service processor
//

pub trait DatabaseDriverSyncHandler {
  /// Create a new, uninitialized database object.
  /// Corresponds to AdbcDatabaseNew.
  /// @return An opaque handle to the server-side database object.
  fn handle_database_new(&self) -> thrift::Result<DatabaseHandle>;
  /// Set a string-valued option for a database.
  /// Corresponds to AdbcDatabaseSetOption.
  fn handle_database_set_option_string(&self, db_handle: DatabaseHandle, key: String, value: String) -> thrift::Result<()>;
  /// Set a byte-valued option for a database.
  /// Corresponds to AdbcDatabaseSetOptionBytes.
  fn handle_database_set_option_bytes(&self, db_handle: DatabaseHandle, key: String, value: Vec<u8>) -> thrift::Result<()>;
  /// Set an integer-valued option for a database.
  /// Corresponds to AdbcDatabaseSetOptionInt.
  fn handle_database_set_option_int(&self, db_handle: DatabaseHandle, key: String, value: i64) -> thrift::Result<()>;
  /// Set a double-valued option for a database.
  /// Corresponds to AdbcDatabaseSetOptionDouble.
  fn handle_database_set_option_double(&self, db_handle: DatabaseHandle, key: String, value: OrderedFloat<f64>) -> thrift::Result<()>;
  /// Finalize database initialization.
  /// Corresponds to AdbcDatabaseInit.
  fn handle_database_init(&self, db_handle: DatabaseHandle) -> thrift::Result<()>;
  /// Release the database object and its resources. The handle is invalidated.
  /// Corresponds to AdbcDatabaseRelease.
  fn handle_database_release(&self, db_handle: DatabaseHandle) -> thrift::Result<()>;
  /// Create a new, uninitialized connection object.
  /// Corresponds to AdbcConnectionNew.
  /// @return An opaque handle to the server-side connection object.
  fn handle_connection_new(&self) -> thrift::Result<ConnectionHandle>;
  /// Set a string-valued option for a connection.
  /// Corresponds to AdbcConnectionSetOption.
  fn handle_connection_set_option_string(&self, conn_handle: ConnectionHandle, key: String, value: String) -> thrift::Result<()>;
  /// Set a byte-valued option for a connection.
  /// Corresponds to AdbcConnectionSetOptionBytes.
  fn handle_connection_set_option_bytes(&self, conn_handle: ConnectionHandle, key: String, value: Vec<u8>) -> thrift::Result<()>;
  /// Set an integer-valued option for a connection.
  /// Corresponds to AdbcConnectionSetOptionInt.
  fn handle_connection_set_option_int(&self, conn_handle: ConnectionHandle, key: String, value: i64) -> thrift::Result<()>;
  /// Set a double-valued option for a connection.
  /// Corresponds to AdbcConnectionSetOptionDouble.
  fn handle_connection_set_option_double(&self, conn_handle: ConnectionHandle, key: String, value: OrderedFloat<f64>) -> thrift::Result<()>;
  /// Finalize connection initialization.
  /// Corresponds to AdbcConnectionInit.
  fn handle_connection_init(&self, conn_handle: ConnectionHandle, db_handle: DatabaseHandle) -> thrift::Result<()>;
  /// Release the connection object and its resources. The handle is invalidated.
  /// Corresponds to AdbcConnectionRelease.
  fn handle_connection_release(&self, conn_handle: ConnectionHandle) -> thrift::Result<()>;
  /// Get metadata about the database/driver.
  /// Corresponds to AdbcConnectionGetInfo.
  /// @param info_codes A list of codes for the metadata to retrieve. If null/empty, retrieve all.
  /// @return An Arrow IPC stream containing the metadata.
  fn handle_connection_get_info(&self, conn_handle: ConnectionHandle, info_codes: Vec<InfoCode>) -> thrift::Result<Vec<u8>>;
  /// Get a hierarchical view of catalogs, DB schemas, tables, and columns.
  /// Corresponds to AdbcConnectionGetObjects.
  /// @return An Arrow IPC stream containing the metadata.
  fn handle_connection_get_objects(&self, conn_handle: ConnectionHandle, depth: i32, catalog: String, db_schema: String, table_name: String, table_type: Vec<String>, column_name: String) -> thrift::Result<Vec<u8>>;
  /// Get the Arrow schema of a table.
  /// Corresponds to AdbcConnectionGetTableSchema.
  /// @return A serialized ArrowSchema in IPC format.
  fn handle_connection_get_table_schema(&self, conn_handle: ConnectionHandle, catalog: String, db_schema: String, table_name: String) -> thrift::Result<Vec<u8>>;
  /// Get a list of table types in the database.
  /// Corresponds to AdbcConnectionGetTableTypes.
  /// @return An Arrow IPC stream containing the table types.
  fn handle_connection_get_table_types(&self, conn_handle: ConnectionHandle) -> thrift::Result<Vec<u8>>;
  /// Commit any pending transactions.
  /// Corresponds to AdbcConnectionCommit.
  fn handle_connection_commit(&self, conn_handle: ConnectionHandle) -> thrift::Result<()>;
  /// Roll back any pending transactions.
  /// Corresponds to AdbcConnectionRollback.
  fn handle_connection_rollback(&self, conn_handle: ConnectionHandle) -> thrift::Result<()>;
  /// Create a new statement.
  /// Corresponds to AdbcStatementNew.
  /// @return An opaque handle to the server-side statement object.
  fn handle_statement_new(&self, conn_handle: ConnectionHandle) -> thrift::Result<StatementHandle>;
  /// Release the statement object.
  /// Corresponds to AdbcStatementRelease.
  fn handle_statement_release(&self, stmt_handle: StatementHandle) -> thrift::Result<()>;
  /// Set the SQL query to execute.
  /// Corresponds to AdbcStatementSetSqlQuery.
  fn handle_statement_set_sql_query(&self, stmt_handle: StatementHandle, query: String) -> thrift::Result<()>;
  /// Set the Substrait plan to execute.
  /// Corresponds to AdbcStatementSetSubstraitPlan.
  fn handle_statement_set_substrait_plan(&self, stmt_handle: StatementHandle, plan: Vec<u8>) -> thrift::Result<()>;
  /// Prepare a statement for execution.
  /// Corresponds to AdbcStatementPrepare.
  fn handle_statement_prepare(&self, stmt_handle: StatementHandle) -> thrift::Result<()>;
  /// Set a string-valued option for a statement.
  /// Corresponds to AdbcStatementSetOption.
  fn handle_statement_set_option_string(&self, stmt_handle: StatementHandle, key: String, value: String) -> thrift::Result<()>;
  /// Set a byte-valued option for a statement.
  /// Corresponds to AdbcStatementSetOptionBytes.
  fn handle_statement_set_option_bytes(&self, stmt_handle: StatementHandle, key: String, value: Vec<u8>) -> thrift::Result<()>;
  /// Set an integer-valued option for a statement.
  /// Corresponds to AdbcStatementSetOptionInt.
  fn handle_statement_set_option_int(&self, stmt_handle: StatementHandle, key: String, value: i64) -> thrift::Result<()>;
  /// Set a double-valued option for a statement.
  /// Corresponds to AdbcStatementSetOptionDouble.
  fn handle_statement_set_option_double(&self, stmt_handle: StatementHandle, key: String, value: OrderedFloat<f64>) -> thrift::Result<()>;
  /// Get the schema for the parameters of a prepared statement.
  /// Corresponds to AdbcStatementGetParameterSchema.
  /// @return A serialized ArrowSchema in IPC format.
  fn handle_statement_get_parameter_schema(&self, stmt_handle: StatementHandle) -> thrift::Result<ArrowSchemaPtr>;
  /// Bind a single batch of values to a prepared statement.
  /// Corresponds to AdbcStatementBind.
  /// @param values An Arrow RecordBatch serialized in IPC format.
  fn handle_statement_bind(&self, stmt_handle: StatementHandle, schema: ArrowSchemaPtr, array: ArrowArrayPtr) -> thrift::Result<()>;
  /// Bind a stream of values to a statement (for bulk ingestion).
  /// Corresponds to AdbcStatementBindStream.
  /// @param stream An Arrow stream serialized in IPC format.
  fn handle_statement_bind_stream(&self, stmt_handle: StatementHandle, stream: Vec<u8>) -> thrift::Result<()>;
  /// Execute a query or a statement with bound data.
  /// Corresponds to AdbcStatementExecuteQuery.
  /// @return An ExecuteResult struct containing the result stream and rows affected.
  fn handle_statement_execute_query(&self, stmt_handle: StatementHandle) -> thrift::Result<ExecuteResult>;
  /// Execute a query and get a description of the result partitions.
  /// Corresponds to AdbcStatementExecutePartitions.
  /// @return A PartitionedResult struct containing schema and partition descriptors.
  fn handle_statement_execute_partitions(&self, stmt_handle: StatementHandle) -> thrift::Result<PartitionedResult>;
  /// Read a single partition of a result set.
  /// Corresponds to AdbcConnectionReadPartition.
  /// @param partition_descriptor An opaque descriptor from statementExecutePartitions.
  /// @return An Arrow IPC stream for the requested partition.
  fn handle_statement_read_partition(&self, stmt_handle: StatementHandle, partition_descriptor: Vec<u8>) -> thrift::Result<i64>;
}

pub struct DatabaseDriverSyncProcessor<H: DatabaseDriverSyncHandler> {
  handler: H,
}

impl <H: DatabaseDriverSyncHandler> DatabaseDriverSyncProcessor<H> {
  pub fn new(handler: H) -> DatabaseDriverSyncProcessor<H> {
    DatabaseDriverSyncProcessor {
      handler,
    }
  }
  fn process_database_new(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_database_new(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_database_set_option_string(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_database_set_option_string(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_database_set_option_bytes(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_database_set_option_bytes(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_database_set_option_int(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_database_set_option_int(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_database_set_option_double(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_database_set_option_double(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_database_init(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_database_init(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_database_release(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_database_release(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_connection_new(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_connection_new(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_connection_set_option_string(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_connection_set_option_string(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_connection_set_option_bytes(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_connection_set_option_bytes(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_connection_set_option_int(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_connection_set_option_int(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_connection_set_option_double(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_connection_set_option_double(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_connection_init(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_connection_init(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_connection_release(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_connection_release(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_connection_get_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_connection_get_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_connection_get_objects(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_connection_get_objects(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_connection_get_table_schema(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_connection_get_table_schema(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_connection_get_table_types(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_connection_get_table_types(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_connection_commit(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_connection_commit(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_connection_rollback(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_connection_rollback(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_statement_new(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_statement_new(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_statement_release(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_statement_release(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_statement_set_sql_query(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_statement_set_sql_query(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_statement_set_substrait_plan(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_statement_set_substrait_plan(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_statement_prepare(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_statement_prepare(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_statement_set_option_string(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_statement_set_option_string(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_statement_set_option_bytes(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_statement_set_option_bytes(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_statement_set_option_int(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_statement_set_option_int(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_statement_set_option_double(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_statement_set_option_double(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_statement_get_parameter_schema(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_statement_get_parameter_schema(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_statement_bind(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_statement_bind(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_statement_bind_stream(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_statement_bind_stream(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_statement_execute_query(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_statement_execute_query(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_statement_execute_partitions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_statement_execute_partitions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_statement_read_partition(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TDatabaseDriverProcessFunctions::process_statement_read_partition(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TDatabaseDriverProcessFunctions;

impl TDatabaseDriverProcessFunctions {
  pub fn process_database_new<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = DatabaseDriverDatabaseNewArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_database_new() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("databaseNew", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverDatabaseNewResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverDatabaseNewResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("databaseNew", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("databaseNew", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("databaseNew", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("databaseNew", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_database_set_option_string<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverDatabaseSetOptionStringArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_database_set_option_string(args.db_handle, args.key, args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("databaseSetOptionString", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverDatabaseSetOptionStringResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverDatabaseSetOptionStringResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("databaseSetOptionString", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("databaseSetOptionString", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("databaseSetOptionString", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("databaseSetOptionString", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_database_set_option_bytes<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverDatabaseSetOptionBytesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_database_set_option_bytes(args.db_handle, args.key, args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("databaseSetOptionBytes", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverDatabaseSetOptionBytesResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverDatabaseSetOptionBytesResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("databaseSetOptionBytes", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("databaseSetOptionBytes", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("databaseSetOptionBytes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("databaseSetOptionBytes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_database_set_option_int<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverDatabaseSetOptionIntArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_database_set_option_int(args.db_handle, args.key, args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("databaseSetOptionInt", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverDatabaseSetOptionIntResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverDatabaseSetOptionIntResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("databaseSetOptionInt", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("databaseSetOptionInt", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("databaseSetOptionInt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("databaseSetOptionInt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_database_set_option_double<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverDatabaseSetOptionDoubleArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_database_set_option_double(args.db_handle, args.key, args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("databaseSetOptionDouble", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverDatabaseSetOptionDoubleResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverDatabaseSetOptionDoubleResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("databaseSetOptionDouble", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("databaseSetOptionDouble", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("databaseSetOptionDouble", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("databaseSetOptionDouble", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_database_init<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverDatabaseInitArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_database_init(args.db_handle) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("databaseInit", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverDatabaseInitResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverDatabaseInitResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("databaseInit", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("databaseInit", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("databaseInit", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("databaseInit", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_database_release<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverDatabaseReleaseArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_database_release(args.db_handle) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("databaseRelease", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverDatabaseReleaseResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverDatabaseReleaseResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("databaseRelease", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("databaseRelease", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("databaseRelease", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("databaseRelease", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_connection_new<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = DatabaseDriverConnectionNewArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_connection_new() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("connectionNew", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverConnectionNewResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverConnectionNewResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("connectionNew", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("connectionNew", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("connectionNew", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("connectionNew", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_connection_set_option_string<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverConnectionSetOptionStringArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_connection_set_option_string(args.conn_handle, args.key, args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("connectionSetOptionString", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverConnectionSetOptionStringResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverConnectionSetOptionStringResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("connectionSetOptionString", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("connectionSetOptionString", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("connectionSetOptionString", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("connectionSetOptionString", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_connection_set_option_bytes<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverConnectionSetOptionBytesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_connection_set_option_bytes(args.conn_handle, args.key, args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("connectionSetOptionBytes", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverConnectionSetOptionBytesResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverConnectionSetOptionBytesResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("connectionSetOptionBytes", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("connectionSetOptionBytes", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("connectionSetOptionBytes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("connectionSetOptionBytes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_connection_set_option_int<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverConnectionSetOptionIntArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_connection_set_option_int(args.conn_handle, args.key, args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("connectionSetOptionInt", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverConnectionSetOptionIntResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverConnectionSetOptionIntResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("connectionSetOptionInt", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("connectionSetOptionInt", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("connectionSetOptionInt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("connectionSetOptionInt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_connection_set_option_double<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverConnectionSetOptionDoubleArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_connection_set_option_double(args.conn_handle, args.key, args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("connectionSetOptionDouble", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverConnectionSetOptionDoubleResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverConnectionSetOptionDoubleResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("connectionSetOptionDouble", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("connectionSetOptionDouble", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("connectionSetOptionDouble", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("connectionSetOptionDouble", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_connection_init<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverConnectionInitArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_connection_init(args.conn_handle, args.db_handle) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("connectionInit", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverConnectionInitResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverConnectionInitResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("connectionInit", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("connectionInit", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("connectionInit", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("connectionInit", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_connection_release<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverConnectionReleaseArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_connection_release(args.conn_handle) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("connectionRelease", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverConnectionReleaseResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverConnectionReleaseResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("connectionRelease", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("connectionRelease", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("connectionRelease", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("connectionRelease", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_connection_get_info<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverConnectionGetInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_connection_get_info(args.conn_handle, args.info_codes) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("connectionGetInfo", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverConnectionGetInfoResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverConnectionGetInfoResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("connectionGetInfo", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("connectionGetInfo", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("connectionGetInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("connectionGetInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_connection_get_objects<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverConnectionGetObjectsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_connection_get_objects(args.conn_handle, args.depth, args.catalog, args.db_schema, args.table_name, args.table_type, args.column_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("connectionGetObjects", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverConnectionGetObjectsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverConnectionGetObjectsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("connectionGetObjects", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("connectionGetObjects", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("connectionGetObjects", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("connectionGetObjects", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_connection_get_table_schema<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverConnectionGetTableSchemaArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_connection_get_table_schema(args.conn_handle, args.catalog, args.db_schema, args.table_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("connectionGetTableSchema", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverConnectionGetTableSchemaResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverConnectionGetTableSchemaResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("connectionGetTableSchema", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("connectionGetTableSchema", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("connectionGetTableSchema", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("connectionGetTableSchema", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_connection_get_table_types<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverConnectionGetTableTypesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_connection_get_table_types(args.conn_handle) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("connectionGetTableTypes", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverConnectionGetTableTypesResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverConnectionGetTableTypesResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("connectionGetTableTypes", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("connectionGetTableTypes", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("connectionGetTableTypes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("connectionGetTableTypes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_connection_commit<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverConnectionCommitArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_connection_commit(args.conn_handle) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("connectionCommit", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverConnectionCommitResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverConnectionCommitResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("connectionCommit", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("connectionCommit", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("connectionCommit", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("connectionCommit", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_connection_rollback<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverConnectionRollbackArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_connection_rollback(args.conn_handle) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("connectionRollback", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverConnectionRollbackResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverConnectionRollbackResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("connectionRollback", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("connectionRollback", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("connectionRollback", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("connectionRollback", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_statement_new<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverStatementNewArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_statement_new(args.conn_handle) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("statementNew", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverStatementNewResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverStatementNewResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("statementNew", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("statementNew", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("statementNew", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("statementNew", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_statement_release<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverStatementReleaseArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_statement_release(args.stmt_handle) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("statementRelease", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverStatementReleaseResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverStatementReleaseResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("statementRelease", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("statementRelease", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("statementRelease", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("statementRelease", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_statement_set_sql_query<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverStatementSetSqlQueryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_statement_set_sql_query(args.stmt_handle, args.query) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("statementSetSqlQuery", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverStatementSetSqlQueryResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverStatementSetSqlQueryResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("statementSetSqlQuery", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("statementSetSqlQuery", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("statementSetSqlQuery", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("statementSetSqlQuery", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_statement_set_substrait_plan<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverStatementSetSubstraitPlanArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_statement_set_substrait_plan(args.stmt_handle, args.plan) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("statementSetSubstraitPlan", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverStatementSetSubstraitPlanResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverStatementSetSubstraitPlanResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("statementSetSubstraitPlan", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("statementSetSubstraitPlan", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("statementSetSubstraitPlan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("statementSetSubstraitPlan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_statement_prepare<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverStatementPrepareArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_statement_prepare(args.stmt_handle) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("statementPrepare", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverStatementPrepareResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverStatementPrepareResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("statementPrepare", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("statementPrepare", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("statementPrepare", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("statementPrepare", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_statement_set_option_string<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverStatementSetOptionStringArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_statement_set_option_string(args.stmt_handle, args.key, args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("statementSetOptionString", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverStatementSetOptionStringResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverStatementSetOptionStringResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("statementSetOptionString", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("statementSetOptionString", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("statementSetOptionString", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("statementSetOptionString", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_statement_set_option_bytes<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverStatementSetOptionBytesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_statement_set_option_bytes(args.stmt_handle, args.key, args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("statementSetOptionBytes", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverStatementSetOptionBytesResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverStatementSetOptionBytesResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("statementSetOptionBytes", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("statementSetOptionBytes", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("statementSetOptionBytes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("statementSetOptionBytes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_statement_set_option_int<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverStatementSetOptionIntArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_statement_set_option_int(args.stmt_handle, args.key, args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("statementSetOptionInt", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverStatementSetOptionIntResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverStatementSetOptionIntResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("statementSetOptionInt", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("statementSetOptionInt", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("statementSetOptionInt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("statementSetOptionInt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_statement_set_option_double<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverStatementSetOptionDoubleArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_statement_set_option_double(args.stmt_handle, args.key, args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("statementSetOptionDouble", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverStatementSetOptionDoubleResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverStatementSetOptionDoubleResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("statementSetOptionDouble", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("statementSetOptionDouble", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("statementSetOptionDouble", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("statementSetOptionDouble", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_statement_get_parameter_schema<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverStatementGetParameterSchemaArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_statement_get_parameter_schema(args.stmt_handle) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("statementGetParameterSchema", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverStatementGetParameterSchemaResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverStatementGetParameterSchemaResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("statementGetParameterSchema", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("statementGetParameterSchema", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("statementGetParameterSchema", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("statementGetParameterSchema", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_statement_bind<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverStatementBindArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_statement_bind(args.stmt_handle, args.schema, args.array) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("statementBind", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverStatementBindResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverStatementBindResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("statementBind", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("statementBind", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("statementBind", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("statementBind", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_statement_bind_stream<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverStatementBindStreamArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_statement_bind_stream(args.stmt_handle, args.stream) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("statementBindStream", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverStatementBindStreamResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverStatementBindStreamResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("statementBindStream", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("statementBindStream", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("statementBindStream", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("statementBindStream", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_statement_execute_query<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverStatementExecuteQueryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_statement_execute_query(args.stmt_handle) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("statementExecuteQuery", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverStatementExecuteQueryResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverStatementExecuteQueryResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("statementExecuteQuery", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("statementExecuteQuery", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("statementExecuteQuery", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("statementExecuteQuery", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_statement_execute_partitions<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverStatementExecutePartitionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_statement_execute_partitions(args.stmt_handle) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("statementExecutePartitions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverStatementExecutePartitionsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverStatementExecutePartitionsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("statementExecutePartitions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("statementExecutePartitions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("statementExecutePartitions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("statementExecutePartitions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_statement_read_partition<H: DatabaseDriverSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = DatabaseDriverStatementReadPartitionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_statement_read_partition(args.stmt_handle, args.partition_descriptor) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("statementReadPartition", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DatabaseDriverStatementReadPartitionResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<DriverException>().is_some() {
              let err = usr_err.downcast::<DriverException>().expect("downcast already checked");
              let ret_err = DatabaseDriverStatementReadPartitionResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("statementReadPartition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("statementReadPartition", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("statementReadPartition", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("statementReadPartition", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: DatabaseDriverSyncHandler> TProcessor for DatabaseDriverSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "databaseNew" => {
        self.process_database_new(message_ident.sequence_number, i_prot, o_prot)
      },
      "databaseSetOptionString" => {
        self.process_database_set_option_string(message_ident.sequence_number, i_prot, o_prot)
      },
      "databaseSetOptionBytes" => {
        self.process_database_set_option_bytes(message_ident.sequence_number, i_prot, o_prot)
      },
      "databaseSetOptionInt" => {
        self.process_database_set_option_int(message_ident.sequence_number, i_prot, o_prot)
      },
      "databaseSetOptionDouble" => {
        self.process_database_set_option_double(message_ident.sequence_number, i_prot, o_prot)
      },
      "databaseInit" => {
        self.process_database_init(message_ident.sequence_number, i_prot, o_prot)
      },
      "databaseRelease" => {
        self.process_database_release(message_ident.sequence_number, i_prot, o_prot)
      },
      "connectionNew" => {
        self.process_connection_new(message_ident.sequence_number, i_prot, o_prot)
      },
      "connectionSetOptionString" => {
        self.process_connection_set_option_string(message_ident.sequence_number, i_prot, o_prot)
      },
      "connectionSetOptionBytes" => {
        self.process_connection_set_option_bytes(message_ident.sequence_number, i_prot, o_prot)
      },
      "connectionSetOptionInt" => {
        self.process_connection_set_option_int(message_ident.sequence_number, i_prot, o_prot)
      },
      "connectionSetOptionDouble" => {
        self.process_connection_set_option_double(message_ident.sequence_number, i_prot, o_prot)
      },
      "connectionInit" => {
        self.process_connection_init(message_ident.sequence_number, i_prot, o_prot)
      },
      "connectionRelease" => {
        self.process_connection_release(message_ident.sequence_number, i_prot, o_prot)
      },
      "connectionGetInfo" => {
        self.process_connection_get_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "connectionGetObjects" => {
        self.process_connection_get_objects(message_ident.sequence_number, i_prot, o_prot)
      },
      "connectionGetTableSchema" => {
        self.process_connection_get_table_schema(message_ident.sequence_number, i_prot, o_prot)
      },
      "connectionGetTableTypes" => {
        self.process_connection_get_table_types(message_ident.sequence_number, i_prot, o_prot)
      },
      "connectionCommit" => {
        self.process_connection_commit(message_ident.sequence_number, i_prot, o_prot)
      },
      "connectionRollback" => {
        self.process_connection_rollback(message_ident.sequence_number, i_prot, o_prot)
      },
      "statementNew" => {
        self.process_statement_new(message_ident.sequence_number, i_prot, o_prot)
      },
      "statementRelease" => {
        self.process_statement_release(message_ident.sequence_number, i_prot, o_prot)
      },
      "statementSetSqlQuery" => {
        self.process_statement_set_sql_query(message_ident.sequence_number, i_prot, o_prot)
      },
      "statementSetSubstraitPlan" => {
        self.process_statement_set_substrait_plan(message_ident.sequence_number, i_prot, o_prot)
      },
      "statementPrepare" => {
        self.process_statement_prepare(message_ident.sequence_number, i_prot, o_prot)
      },
      "statementSetOptionString" => {
        self.process_statement_set_option_string(message_ident.sequence_number, i_prot, o_prot)
      },
      "statementSetOptionBytes" => {
        self.process_statement_set_option_bytes(message_ident.sequence_number, i_prot, o_prot)
      },
      "statementSetOptionInt" => {
        self.process_statement_set_option_int(message_ident.sequence_number, i_prot, o_prot)
      },
      "statementSetOptionDouble" => {
        self.process_statement_set_option_double(message_ident.sequence_number, i_prot, o_prot)
      },
      "statementGetParameterSchema" => {
        self.process_statement_get_parameter_schema(message_ident.sequence_number, i_prot, o_prot)
      },
      "statementBind" => {
        self.process_statement_bind(message_ident.sequence_number, i_prot, o_prot)
      },
      "statementBindStream" => {
        self.process_statement_bind_stream(message_ident.sequence_number, i_prot, o_prot)
      },
      "statementExecuteQuery" => {
        self.process_statement_execute_query(message_ident.sequence_number, i_prot, o_prot)
      },
      "statementExecutePartitions" => {
        self.process_statement_execute_partitions(message_ident.sequence_number, i_prot, o_prot)
      },
      "statementReadPartition" => {
        self.process_statement_read_partition(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// DatabaseDriverDatabaseNewArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverDatabaseNewArgs {
}

impl DatabaseDriverDatabaseNewArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverDatabaseNewArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverDatabaseNewArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("databaseNew_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverDatabaseNewResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverDatabaseNewResult {
  result_value: Option<DatabaseHandle>,
  e: Option<DriverException>,
}

impl DatabaseDriverDatabaseNewResult {
  fn ok_or(self) -> thrift::Result<DatabaseHandle> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for DatabaseDriverDatabaseNew"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverDatabaseNewResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<DatabaseHandle> = None;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = DatabaseHandle::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverDatabaseNewResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverDatabaseNewResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverDatabaseSetOptionStringArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverDatabaseSetOptionStringArgs {
  db_handle: DatabaseHandle,
  key: String,
  value: String,
}

impl DatabaseDriverDatabaseSetOptionStringArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverDatabaseSetOptionStringArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DatabaseHandle> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DatabaseHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverDatabaseSetOptionStringArgs.db_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverDatabaseSetOptionStringArgs.key", &f_2)?;
    verify_required_field_exists("DatabaseDriverDatabaseSetOptionStringArgs.value", &f_3)?;
    let ret = DatabaseDriverDatabaseSetOptionStringArgs {
      db_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("databaseSetOptionString_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_handle", TType::Struct, 1))?;
    self.db_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 3))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverDatabaseSetOptionStringResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverDatabaseSetOptionStringResult {
  e: Option<DriverException>,
}

impl DatabaseDriverDatabaseSetOptionStringResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverDatabaseSetOptionStringResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverDatabaseSetOptionStringResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverDatabaseSetOptionStringResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverDatabaseSetOptionBytesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverDatabaseSetOptionBytesArgs {
  db_handle: DatabaseHandle,
  key: String,
  value: Vec<u8>,
}

impl DatabaseDriverDatabaseSetOptionBytesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverDatabaseSetOptionBytesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DatabaseHandle> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DatabaseHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverDatabaseSetOptionBytesArgs.db_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverDatabaseSetOptionBytesArgs.key", &f_2)?;
    verify_required_field_exists("DatabaseDriverDatabaseSetOptionBytesArgs.value", &f_3)?;
    let ret = DatabaseDriverDatabaseSetOptionBytesArgs {
      db_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("databaseSetOptionBytes_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_handle", TType::Struct, 1))?;
    self.db_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 3))?;
    o_prot.write_bytes(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverDatabaseSetOptionBytesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverDatabaseSetOptionBytesResult {
  e: Option<DriverException>,
}

impl DatabaseDriverDatabaseSetOptionBytesResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverDatabaseSetOptionBytesResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverDatabaseSetOptionBytesResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverDatabaseSetOptionBytesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverDatabaseSetOptionIntArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverDatabaseSetOptionIntArgs {
  db_handle: DatabaseHandle,
  key: String,
  value: i64,
}

impl DatabaseDriverDatabaseSetOptionIntArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverDatabaseSetOptionIntArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DatabaseHandle> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DatabaseHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverDatabaseSetOptionIntArgs.db_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverDatabaseSetOptionIntArgs.key", &f_2)?;
    verify_required_field_exists("DatabaseDriverDatabaseSetOptionIntArgs.value", &f_3)?;
    let ret = DatabaseDriverDatabaseSetOptionIntArgs {
      db_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("databaseSetOptionInt_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_handle", TType::Struct, 1))?;
    self.db_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::I64, 3))?;
    o_prot.write_i64(self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverDatabaseSetOptionIntResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverDatabaseSetOptionIntResult {
  e: Option<DriverException>,
}

impl DatabaseDriverDatabaseSetOptionIntResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverDatabaseSetOptionIntResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverDatabaseSetOptionIntResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverDatabaseSetOptionIntResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverDatabaseSetOptionDoubleArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverDatabaseSetOptionDoubleArgs {
  db_handle: DatabaseHandle,
  key: String,
  value: OrderedFloat<f64>,
}

impl DatabaseDriverDatabaseSetOptionDoubleArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverDatabaseSetOptionDoubleArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DatabaseHandle> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<OrderedFloat<f64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DatabaseHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverDatabaseSetOptionDoubleArgs.db_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverDatabaseSetOptionDoubleArgs.key", &f_2)?;
    verify_required_field_exists("DatabaseDriverDatabaseSetOptionDoubleArgs.value", &f_3)?;
    let ret = DatabaseDriverDatabaseSetOptionDoubleArgs {
      db_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("databaseSetOptionDouble_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_handle", TType::Struct, 1))?;
    self.db_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::Double, 3))?;
    o_prot.write_double(self.value.into())?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverDatabaseSetOptionDoubleResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverDatabaseSetOptionDoubleResult {
  e: Option<DriverException>,
}

impl DatabaseDriverDatabaseSetOptionDoubleResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverDatabaseSetOptionDoubleResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverDatabaseSetOptionDoubleResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverDatabaseSetOptionDoubleResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverDatabaseInitArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverDatabaseInitArgs {
  db_handle: DatabaseHandle,
}

impl DatabaseDriverDatabaseInitArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverDatabaseInitArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DatabaseHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DatabaseHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverDatabaseInitArgs.db_handle", &f_1)?;
    let ret = DatabaseDriverDatabaseInitArgs {
      db_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("databaseInit_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_handle", TType::Struct, 1))?;
    self.db_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverDatabaseInitResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverDatabaseInitResult {
  e: Option<DriverException>,
}

impl DatabaseDriverDatabaseInitResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverDatabaseInitResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverDatabaseInitResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverDatabaseInitResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverDatabaseReleaseArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverDatabaseReleaseArgs {
  db_handle: DatabaseHandle,
}

impl DatabaseDriverDatabaseReleaseArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverDatabaseReleaseArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DatabaseHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DatabaseHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverDatabaseReleaseArgs.db_handle", &f_1)?;
    let ret = DatabaseDriverDatabaseReleaseArgs {
      db_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("databaseRelease_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_handle", TType::Struct, 1))?;
    self.db_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverDatabaseReleaseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverDatabaseReleaseResult {
  e: Option<DriverException>,
}

impl DatabaseDriverDatabaseReleaseResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverDatabaseReleaseResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverDatabaseReleaseResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverDatabaseReleaseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionNewArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionNewArgs {
}

impl DatabaseDriverConnectionNewArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionNewArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverConnectionNewArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("connectionNew_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionNewResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionNewResult {
  result_value: Option<ConnectionHandle>,
  e: Option<DriverException>,
}

impl DatabaseDriverConnectionNewResult {
  fn ok_or(self) -> thrift::Result<ConnectionHandle> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for DatabaseDriverConnectionNew"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionNewResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ConnectionHandle> = None;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ConnectionHandle::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverConnectionNewResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverConnectionNewResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionSetOptionStringArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionSetOptionStringArgs {
  conn_handle: ConnectionHandle,
  key: String,
  value: String,
}

impl DatabaseDriverConnectionSetOptionStringArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionSetOptionStringArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ConnectionHandle> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ConnectionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverConnectionSetOptionStringArgs.conn_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverConnectionSetOptionStringArgs.key", &f_2)?;
    verify_required_field_exists("DatabaseDriverConnectionSetOptionStringArgs.value", &f_3)?;
    let ret = DatabaseDriverConnectionSetOptionStringArgs {
      conn_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("connectionSetOptionString_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("conn_handle", TType::Struct, 1))?;
    self.conn_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 3))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionSetOptionStringResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionSetOptionStringResult {
  e: Option<DriverException>,
}

impl DatabaseDriverConnectionSetOptionStringResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionSetOptionStringResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverConnectionSetOptionStringResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverConnectionSetOptionStringResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionSetOptionBytesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionSetOptionBytesArgs {
  conn_handle: ConnectionHandle,
  key: String,
  value: Vec<u8>,
}

impl DatabaseDriverConnectionSetOptionBytesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionSetOptionBytesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ConnectionHandle> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ConnectionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverConnectionSetOptionBytesArgs.conn_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverConnectionSetOptionBytesArgs.key", &f_2)?;
    verify_required_field_exists("DatabaseDriverConnectionSetOptionBytesArgs.value", &f_3)?;
    let ret = DatabaseDriverConnectionSetOptionBytesArgs {
      conn_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("connectionSetOptionBytes_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("conn_handle", TType::Struct, 1))?;
    self.conn_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 3))?;
    o_prot.write_bytes(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionSetOptionBytesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionSetOptionBytesResult {
  e: Option<DriverException>,
}

impl DatabaseDriverConnectionSetOptionBytesResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionSetOptionBytesResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverConnectionSetOptionBytesResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverConnectionSetOptionBytesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionSetOptionIntArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionSetOptionIntArgs {
  conn_handle: ConnectionHandle,
  key: String,
  value: i64,
}

impl DatabaseDriverConnectionSetOptionIntArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionSetOptionIntArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ConnectionHandle> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ConnectionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverConnectionSetOptionIntArgs.conn_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverConnectionSetOptionIntArgs.key", &f_2)?;
    verify_required_field_exists("DatabaseDriverConnectionSetOptionIntArgs.value", &f_3)?;
    let ret = DatabaseDriverConnectionSetOptionIntArgs {
      conn_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("connectionSetOptionInt_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("conn_handle", TType::Struct, 1))?;
    self.conn_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::I64, 3))?;
    o_prot.write_i64(self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionSetOptionIntResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionSetOptionIntResult {
  e: Option<DriverException>,
}

impl DatabaseDriverConnectionSetOptionIntResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionSetOptionIntResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverConnectionSetOptionIntResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverConnectionSetOptionIntResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionSetOptionDoubleArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionSetOptionDoubleArgs {
  conn_handle: ConnectionHandle,
  key: String,
  value: OrderedFloat<f64>,
}

impl DatabaseDriverConnectionSetOptionDoubleArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionSetOptionDoubleArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ConnectionHandle> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<OrderedFloat<f64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ConnectionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverConnectionSetOptionDoubleArgs.conn_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverConnectionSetOptionDoubleArgs.key", &f_2)?;
    verify_required_field_exists("DatabaseDriverConnectionSetOptionDoubleArgs.value", &f_3)?;
    let ret = DatabaseDriverConnectionSetOptionDoubleArgs {
      conn_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("connectionSetOptionDouble_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("conn_handle", TType::Struct, 1))?;
    self.conn_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::Double, 3))?;
    o_prot.write_double(self.value.into())?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionSetOptionDoubleResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionSetOptionDoubleResult {
  e: Option<DriverException>,
}

impl DatabaseDriverConnectionSetOptionDoubleResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionSetOptionDoubleResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverConnectionSetOptionDoubleResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverConnectionSetOptionDoubleResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionInitArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionInitArgs {
  conn_handle: ConnectionHandle,
  db_handle: DatabaseHandle,
}

impl DatabaseDriverConnectionInitArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionInitArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ConnectionHandle> = None;
    let mut f_2: Option<DatabaseHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ConnectionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = DatabaseHandle::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverConnectionInitArgs.conn_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverConnectionInitArgs.db_handle", &f_2)?;
    let ret = DatabaseDriverConnectionInitArgs {
      conn_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      db_handle: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("connectionInit_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("conn_handle", TType::Struct, 1))?;
    self.conn_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_handle", TType::Struct, 2))?;
    self.db_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionInitResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionInitResult {
  e: Option<DriverException>,
}

impl DatabaseDriverConnectionInitResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionInitResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverConnectionInitResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverConnectionInitResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionReleaseArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionReleaseArgs {
  conn_handle: ConnectionHandle,
}

impl DatabaseDriverConnectionReleaseArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionReleaseArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ConnectionHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ConnectionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverConnectionReleaseArgs.conn_handle", &f_1)?;
    let ret = DatabaseDriverConnectionReleaseArgs {
      conn_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("connectionRelease_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("conn_handle", TType::Struct, 1))?;
    self.conn_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionReleaseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionReleaseResult {
  e: Option<DriverException>,
}

impl DatabaseDriverConnectionReleaseResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionReleaseResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverConnectionReleaseResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverConnectionReleaseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionGetInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionGetInfoArgs {
  conn_handle: ConnectionHandle,
  info_codes: Vec<InfoCode>,
}

impl DatabaseDriverConnectionGetInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionGetInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ConnectionHandle> = None;
    let mut f_2: Option<Vec<InfoCode>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ConnectionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<InfoCode> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = InfoCode::read_from_in_protocol(i_prot)?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverConnectionGetInfoArgs.conn_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverConnectionGetInfoArgs.info_codes", &f_2)?;
    let ret = DatabaseDriverConnectionGetInfoArgs {
      conn_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      info_codes: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("connectionGetInfo_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("conn_handle", TType::Struct, 1))?;
    self.conn_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("info_codes", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.info_codes.len() as i32))?;
    for e in &self.info_codes {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionGetInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionGetInfoResult {
  result_value: Option<Vec<u8>>,
  e: Option<DriverException>,
}

impl DatabaseDriverConnectionGetInfoResult {
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for DatabaseDriverConnectionGetInfo"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionGetInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverConnectionGetInfoResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverConnectionGetInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionGetObjectsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionGetObjectsArgs {
  conn_handle: ConnectionHandle,
  depth: i32,
  catalog: String,
  db_schema: String,
  table_name: String,
  table_type: Vec<String>,
  column_name: String,
}

impl DatabaseDriverConnectionGetObjectsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionGetObjectsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ConnectionHandle> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<Vec<String>> = None;
    let mut f_7: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ConnectionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = i_prot.read_string()?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverConnectionGetObjectsArgs.conn_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverConnectionGetObjectsArgs.depth", &f_2)?;
    verify_required_field_exists("DatabaseDriverConnectionGetObjectsArgs.catalog", &f_3)?;
    verify_required_field_exists("DatabaseDriverConnectionGetObjectsArgs.db_schema", &f_4)?;
    verify_required_field_exists("DatabaseDriverConnectionGetObjectsArgs.table_name", &f_5)?;
    verify_required_field_exists("DatabaseDriverConnectionGetObjectsArgs.table_type", &f_6)?;
    verify_required_field_exists("DatabaseDriverConnectionGetObjectsArgs.column_name", &f_7)?;
    let ret = DatabaseDriverConnectionGetObjectsArgs {
      conn_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      depth: f_2.expect("auto-generated code should have checked for presence of required fields"),
      catalog: f_3.expect("auto-generated code should have checked for presence of required fields"),
      db_schema: f_4.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_5.expect("auto-generated code should have checked for presence of required fields"),
      table_type: f_6.expect("auto-generated code should have checked for presence of required fields"),
      column_name: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("connectionGetObjects_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("conn_handle", TType::Struct, 1))?;
    self.conn_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("depth", TType::I32, 2))?;
    o_prot.write_i32(self.depth)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("catalog", TType::String, 3))?;
    o_prot.write_string(&self.catalog)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_schema", TType::String, 4))?;
    o_prot.write_string(&self.db_schema)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 5))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_type", TType::List, 6))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.table_type.len() as i32))?;
    for e in &self.table_type {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("column_name", TType::String, 7))?;
    o_prot.write_string(&self.column_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionGetObjectsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionGetObjectsResult {
  result_value: Option<Vec<u8>>,
  e: Option<DriverException>,
}

impl DatabaseDriverConnectionGetObjectsResult {
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for DatabaseDriverConnectionGetObjects"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionGetObjectsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverConnectionGetObjectsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverConnectionGetObjectsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionGetTableSchemaArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionGetTableSchemaArgs {
  conn_handle: ConnectionHandle,
  catalog: String,
  db_schema: String,
  table_name: String,
}

impl DatabaseDriverConnectionGetTableSchemaArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionGetTableSchemaArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ConnectionHandle> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ConnectionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverConnectionGetTableSchemaArgs.conn_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverConnectionGetTableSchemaArgs.catalog", &f_2)?;
    verify_required_field_exists("DatabaseDriverConnectionGetTableSchemaArgs.db_schema", &f_3)?;
    verify_required_field_exists("DatabaseDriverConnectionGetTableSchemaArgs.table_name", &f_4)?;
    let ret = DatabaseDriverConnectionGetTableSchemaArgs {
      conn_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      catalog: f_2.expect("auto-generated code should have checked for presence of required fields"),
      db_schema: f_3.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("connectionGetTableSchema_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("conn_handle", TType::Struct, 1))?;
    self.conn_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("catalog", TType::String, 2))?;
    o_prot.write_string(&self.catalog)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_schema", TType::String, 3))?;
    o_prot.write_string(&self.db_schema)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 4))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionGetTableSchemaResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionGetTableSchemaResult {
  result_value: Option<Vec<u8>>,
  e: Option<DriverException>,
}

impl DatabaseDriverConnectionGetTableSchemaResult {
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for DatabaseDriverConnectionGetTableSchema"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionGetTableSchemaResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverConnectionGetTableSchemaResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverConnectionGetTableSchemaResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionGetTableTypesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionGetTableTypesArgs {
  conn_handle: ConnectionHandle,
}

impl DatabaseDriverConnectionGetTableTypesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionGetTableTypesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ConnectionHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ConnectionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverConnectionGetTableTypesArgs.conn_handle", &f_1)?;
    let ret = DatabaseDriverConnectionGetTableTypesArgs {
      conn_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("connectionGetTableTypes_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("conn_handle", TType::Struct, 1))?;
    self.conn_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionGetTableTypesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionGetTableTypesResult {
  result_value: Option<Vec<u8>>,
  e: Option<DriverException>,
}

impl DatabaseDriverConnectionGetTableTypesResult {
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for DatabaseDriverConnectionGetTableTypes"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionGetTableTypesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverConnectionGetTableTypesResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverConnectionGetTableTypesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionCommitArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionCommitArgs {
  conn_handle: ConnectionHandle,
}

impl DatabaseDriverConnectionCommitArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionCommitArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ConnectionHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ConnectionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverConnectionCommitArgs.conn_handle", &f_1)?;
    let ret = DatabaseDriverConnectionCommitArgs {
      conn_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("connectionCommit_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("conn_handle", TType::Struct, 1))?;
    self.conn_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionCommitResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionCommitResult {
  e: Option<DriverException>,
}

impl DatabaseDriverConnectionCommitResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionCommitResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverConnectionCommitResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverConnectionCommitResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionRollbackArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionRollbackArgs {
  conn_handle: ConnectionHandle,
}

impl DatabaseDriverConnectionRollbackArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionRollbackArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ConnectionHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ConnectionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverConnectionRollbackArgs.conn_handle", &f_1)?;
    let ret = DatabaseDriverConnectionRollbackArgs {
      conn_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("connectionRollback_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("conn_handle", TType::Struct, 1))?;
    self.conn_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverConnectionRollbackResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverConnectionRollbackResult {
  e: Option<DriverException>,
}

impl DatabaseDriverConnectionRollbackResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverConnectionRollbackResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverConnectionRollbackResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverConnectionRollbackResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementNewArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementNewArgs {
  conn_handle: ConnectionHandle,
}

impl DatabaseDriverStatementNewArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementNewArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ConnectionHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ConnectionHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverStatementNewArgs.conn_handle", &f_1)?;
    let ret = DatabaseDriverStatementNewArgs {
      conn_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("statementNew_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("conn_handle", TType::Struct, 1))?;
    self.conn_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementNewResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementNewResult {
  result_value: Option<StatementHandle>,
  e: Option<DriverException>,
}

impl DatabaseDriverStatementNewResult {
  fn ok_or(self) -> thrift::Result<StatementHandle> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for DatabaseDriverStatementNew"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementNewResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<StatementHandle> = None;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = StatementHandle::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverStatementNewResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverStatementNewResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementReleaseArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementReleaseArgs {
  stmt_handle: StatementHandle,
}

impl DatabaseDriverStatementReleaseArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementReleaseArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<StatementHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = StatementHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverStatementReleaseArgs.stmt_handle", &f_1)?;
    let ret = DatabaseDriverStatementReleaseArgs {
      stmt_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("statementRelease_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stmt_handle", TType::Struct, 1))?;
    self.stmt_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementReleaseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementReleaseResult {
  e: Option<DriverException>,
}

impl DatabaseDriverStatementReleaseResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementReleaseResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverStatementReleaseResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverStatementReleaseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementSetSqlQueryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementSetSqlQueryArgs {
  stmt_handle: StatementHandle,
  query: String,
}

impl DatabaseDriverStatementSetSqlQueryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementSetSqlQueryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<StatementHandle> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = StatementHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverStatementSetSqlQueryArgs.stmt_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverStatementSetSqlQueryArgs.query", &f_2)?;
    let ret = DatabaseDriverStatementSetSqlQueryArgs {
      stmt_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("statementSetSqlQuery_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stmt_handle", TType::Struct, 1))?;
    self.stmt_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 2))?;
    o_prot.write_string(&self.query)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementSetSqlQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementSetSqlQueryResult {
  e: Option<DriverException>,
}

impl DatabaseDriverStatementSetSqlQueryResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementSetSqlQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverStatementSetSqlQueryResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverStatementSetSqlQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementSetSubstraitPlanArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementSetSubstraitPlanArgs {
  stmt_handle: StatementHandle,
  plan: Vec<u8>,
}

impl DatabaseDriverStatementSetSubstraitPlanArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementSetSubstraitPlanArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<StatementHandle> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = StatementHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverStatementSetSubstraitPlanArgs.stmt_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverStatementSetSubstraitPlanArgs.plan", &f_2)?;
    let ret = DatabaseDriverStatementSetSubstraitPlanArgs {
      stmt_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      plan: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("statementSetSubstraitPlan_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stmt_handle", TType::Struct, 1))?;
    self.stmt_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("plan", TType::String, 2))?;
    o_prot.write_bytes(&self.plan)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementSetSubstraitPlanResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementSetSubstraitPlanResult {
  e: Option<DriverException>,
}

impl DatabaseDriverStatementSetSubstraitPlanResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementSetSubstraitPlanResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverStatementSetSubstraitPlanResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverStatementSetSubstraitPlanResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementPrepareArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementPrepareArgs {
  stmt_handle: StatementHandle,
}

impl DatabaseDriverStatementPrepareArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementPrepareArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<StatementHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = StatementHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverStatementPrepareArgs.stmt_handle", &f_1)?;
    let ret = DatabaseDriverStatementPrepareArgs {
      stmt_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("statementPrepare_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stmt_handle", TType::Struct, 1))?;
    self.stmt_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementPrepareResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementPrepareResult {
  e: Option<DriverException>,
}

impl DatabaseDriverStatementPrepareResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementPrepareResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverStatementPrepareResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverStatementPrepareResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementSetOptionStringArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementSetOptionStringArgs {
  stmt_handle: StatementHandle,
  key: String,
  value: String,
}

impl DatabaseDriverStatementSetOptionStringArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementSetOptionStringArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<StatementHandle> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = StatementHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverStatementSetOptionStringArgs.stmt_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverStatementSetOptionStringArgs.key", &f_2)?;
    verify_required_field_exists("DatabaseDriverStatementSetOptionStringArgs.value", &f_3)?;
    let ret = DatabaseDriverStatementSetOptionStringArgs {
      stmt_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("statementSetOptionString_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stmt_handle", TType::Struct, 1))?;
    self.stmt_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 3))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementSetOptionStringResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementSetOptionStringResult {
  e: Option<DriverException>,
}

impl DatabaseDriverStatementSetOptionStringResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementSetOptionStringResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverStatementSetOptionStringResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverStatementSetOptionStringResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementSetOptionBytesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementSetOptionBytesArgs {
  stmt_handle: StatementHandle,
  key: String,
  value: Vec<u8>,
}

impl DatabaseDriverStatementSetOptionBytesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementSetOptionBytesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<StatementHandle> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = StatementHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverStatementSetOptionBytesArgs.stmt_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverStatementSetOptionBytesArgs.key", &f_2)?;
    verify_required_field_exists("DatabaseDriverStatementSetOptionBytesArgs.value", &f_3)?;
    let ret = DatabaseDriverStatementSetOptionBytesArgs {
      stmt_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("statementSetOptionBytes_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stmt_handle", TType::Struct, 1))?;
    self.stmt_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 3))?;
    o_prot.write_bytes(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementSetOptionBytesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementSetOptionBytesResult {
  e: Option<DriverException>,
}

impl DatabaseDriverStatementSetOptionBytesResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementSetOptionBytesResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverStatementSetOptionBytesResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverStatementSetOptionBytesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementSetOptionIntArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementSetOptionIntArgs {
  stmt_handle: StatementHandle,
  key: String,
  value: i64,
}

impl DatabaseDriverStatementSetOptionIntArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementSetOptionIntArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<StatementHandle> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = StatementHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverStatementSetOptionIntArgs.stmt_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverStatementSetOptionIntArgs.key", &f_2)?;
    verify_required_field_exists("DatabaseDriverStatementSetOptionIntArgs.value", &f_3)?;
    let ret = DatabaseDriverStatementSetOptionIntArgs {
      stmt_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("statementSetOptionInt_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stmt_handle", TType::Struct, 1))?;
    self.stmt_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::I64, 3))?;
    o_prot.write_i64(self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementSetOptionIntResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementSetOptionIntResult {
  e: Option<DriverException>,
}

impl DatabaseDriverStatementSetOptionIntResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementSetOptionIntResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverStatementSetOptionIntResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverStatementSetOptionIntResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementSetOptionDoubleArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementSetOptionDoubleArgs {
  stmt_handle: StatementHandle,
  key: String,
  value: OrderedFloat<f64>,
}

impl DatabaseDriverStatementSetOptionDoubleArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementSetOptionDoubleArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<StatementHandle> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<OrderedFloat<f64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = StatementHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverStatementSetOptionDoubleArgs.stmt_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverStatementSetOptionDoubleArgs.key", &f_2)?;
    verify_required_field_exists("DatabaseDriverStatementSetOptionDoubleArgs.value", &f_3)?;
    let ret = DatabaseDriverStatementSetOptionDoubleArgs {
      stmt_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      value: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("statementSetOptionDouble_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stmt_handle", TType::Struct, 1))?;
    self.stmt_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::Double, 3))?;
    o_prot.write_double(self.value.into())?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementSetOptionDoubleResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementSetOptionDoubleResult {
  e: Option<DriverException>,
}

impl DatabaseDriverStatementSetOptionDoubleResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementSetOptionDoubleResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverStatementSetOptionDoubleResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverStatementSetOptionDoubleResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementGetParameterSchemaArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementGetParameterSchemaArgs {
  stmt_handle: StatementHandle,
}

impl DatabaseDriverStatementGetParameterSchemaArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementGetParameterSchemaArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<StatementHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = StatementHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverStatementGetParameterSchemaArgs.stmt_handle", &f_1)?;
    let ret = DatabaseDriverStatementGetParameterSchemaArgs {
      stmt_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("statementGetParameterSchema_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stmt_handle", TType::Struct, 1))?;
    self.stmt_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementGetParameterSchemaResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementGetParameterSchemaResult {
  result_value: Option<ArrowSchemaPtr>,
  e: Option<DriverException>,
}

impl DatabaseDriverStatementGetParameterSchemaResult {
  fn ok_or(self) -> thrift::Result<ArrowSchemaPtr> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for DatabaseDriverStatementGetParameterSchema"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementGetParameterSchemaResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ArrowSchemaPtr> = None;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ArrowSchemaPtr::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverStatementGetParameterSchemaResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverStatementGetParameterSchemaResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementBindArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementBindArgs {
  stmt_handle: StatementHandle,
  schema: ArrowSchemaPtr,
  array: ArrowArrayPtr,
}

impl DatabaseDriverStatementBindArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementBindArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<StatementHandle> = None;
    let mut f_2: Option<ArrowSchemaPtr> = None;
    let mut f_3: Option<ArrowArrayPtr> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = StatementHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = ArrowSchemaPtr::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = ArrowArrayPtr::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverStatementBindArgs.stmt_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverStatementBindArgs.schema", &f_2)?;
    verify_required_field_exists("DatabaseDriverStatementBindArgs.array", &f_3)?;
    let ret = DatabaseDriverStatementBindArgs {
      stmt_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      schema: f_2.expect("auto-generated code should have checked for presence of required fields"),
      array: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("statementBind_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stmt_handle", TType::Struct, 1))?;
    self.stmt_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("schema", TType::Struct, 2))?;
    self.schema.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("array", TType::Struct, 3))?;
    self.array.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementBindResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementBindResult {
  e: Option<DriverException>,
}

impl DatabaseDriverStatementBindResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementBindResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverStatementBindResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverStatementBindResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementBindStreamArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementBindStreamArgs {
  stmt_handle: StatementHandle,
  stream: Vec<u8>,
}

impl DatabaseDriverStatementBindStreamArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementBindStreamArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<StatementHandle> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = StatementHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverStatementBindStreamArgs.stmt_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverStatementBindStreamArgs.stream", &f_2)?;
    let ret = DatabaseDriverStatementBindStreamArgs {
      stmt_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      stream: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("statementBindStream_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stmt_handle", TType::Struct, 1))?;
    self.stmt_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stream", TType::String, 2))?;
    o_prot.write_bytes(&self.stream)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementBindStreamResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementBindStreamResult {
  e: Option<DriverException>,
}

impl DatabaseDriverStatementBindStreamResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementBindStreamResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverStatementBindStreamResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverStatementBindStreamResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementExecuteQueryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementExecuteQueryArgs {
  stmt_handle: StatementHandle,
}

impl DatabaseDriverStatementExecuteQueryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementExecuteQueryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<StatementHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = StatementHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverStatementExecuteQueryArgs.stmt_handle", &f_1)?;
    let ret = DatabaseDriverStatementExecuteQueryArgs {
      stmt_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("statementExecuteQuery_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stmt_handle", TType::Struct, 1))?;
    self.stmt_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementExecuteQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementExecuteQueryResult {
  result_value: Option<ExecuteResult>,
  e: Option<DriverException>,
}

impl DatabaseDriverStatementExecuteQueryResult {
  fn ok_or(self) -> thrift::Result<ExecuteResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for DatabaseDriverStatementExecuteQuery"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementExecuteQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ExecuteResult> = None;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ExecuteResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverStatementExecuteQueryResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverStatementExecuteQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementExecutePartitionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementExecutePartitionsArgs {
  stmt_handle: StatementHandle,
}

impl DatabaseDriverStatementExecutePartitionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementExecutePartitionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<StatementHandle> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = StatementHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverStatementExecutePartitionsArgs.stmt_handle", &f_1)?;
    let ret = DatabaseDriverStatementExecutePartitionsArgs {
      stmt_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("statementExecutePartitions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stmt_handle", TType::Struct, 1))?;
    self.stmt_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementExecutePartitionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementExecutePartitionsResult {
  result_value: Option<PartitionedResult>,
  e: Option<DriverException>,
}

impl DatabaseDriverStatementExecutePartitionsResult {
  fn ok_or(self) -> thrift::Result<PartitionedResult> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for DatabaseDriverStatementExecutePartitions"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementExecutePartitionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<PartitionedResult> = None;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = PartitionedResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverStatementExecutePartitionsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverStatementExecutePartitionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementReadPartitionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementReadPartitionArgs {
  stmt_handle: StatementHandle,
  partition_descriptor: Vec<u8>,
}

impl DatabaseDriverStatementReadPartitionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementReadPartitionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<StatementHandle> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = StatementHandle::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DatabaseDriverStatementReadPartitionArgs.stmt_handle", &f_1)?;
    verify_required_field_exists("DatabaseDriverStatementReadPartitionArgs.partition_descriptor", &f_2)?;
    let ret = DatabaseDriverStatementReadPartitionArgs {
      stmt_handle: f_1.expect("auto-generated code should have checked for presence of required fields"),
      partition_descriptor: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("statementReadPartition_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stmt_handle", TType::Struct, 1))?;
    self.stmt_handle.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partition_descriptor", TType::String, 2))?;
    o_prot.write_bytes(&self.partition_descriptor)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DatabaseDriverStatementReadPartitionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DatabaseDriverStatementReadPartitionResult {
  result_value: Option<i64>,
  e: Option<DriverException>,
}

impl DatabaseDriverStatementReadPartitionResult {
  fn ok_or(self) -> thrift::Result<i64> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for DatabaseDriverStatementReadPartition"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DatabaseDriverStatementReadPartitionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    let mut f_1: Option<DriverException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        1 => {
          let val = DriverException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DatabaseDriverStatementReadPartitionResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DatabaseDriverStatementReadPartitionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

