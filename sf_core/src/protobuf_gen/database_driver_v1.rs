// This file is @generated by prost-build.
/// Error detail message
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ErrorDetail {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// Authentication error details
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AuthenticationError {
    #[prost(string, tag = "1")]
    pub detail: ::prost::alloc::string::String,
}
/// Generic error (empty message)
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GenericError {}
/// Internal error (empty message)
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InternalError {}
/// Login error details
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LoginError {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub code: i32,
}
/// Missing parameter error
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MissingParameter {
    #[prost(string, tag = "1")]
    pub parameter: ::prost::alloc::string::String,
}
/// Invalid parameter value error
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InvalidParameterValue {
    #[prost(string, tag = "1")]
    pub parameter: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3")]
    pub explanation: ::core::option::Option<::prost::alloc::string::String>,
}
/// Driver error union (using oneof)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DriverError {
    #[prost(oneof = "driver_error::ErrorType", tags = "1, 2, 3, 4, 5, 6")]
    pub error_type: ::core::option::Option<driver_error::ErrorType>,
}
/// Nested message and enum types in `DriverError`.
pub mod driver_error {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum ErrorType {
        #[prost(message, tag = "1")]
        AuthError(super::AuthenticationError),
        #[prost(message, tag = "2")]
        GenericError(super::GenericError),
        #[prost(message, tag = "3")]
        InternalError(super::InternalError),
        #[prost(message, tag = "4")]
        MissingParameter(super::MissingParameter),
        #[prost(message, tag = "5")]
        InvalidParameterValue(super::InvalidParameterValue),
        #[prost(message, tag = "6")]
        LoginError(super::LoginError),
    }
}
/// Driver exception
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DriverException {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(enumeration = "StatusCode", tag = "2")]
    pub status_code: i32,
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<DriverError>,
    #[prost(string, tag = "4")]
    pub report: ::prost::alloc::string::String,
}
/// Execute result
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExecuteResult {
    #[prost(message, optional, tag = "1")]
    pub stream: ::core::option::Option<ArrowArrayStreamPtr>,
    #[prost(int64, tag = "2")]
    pub rows_affected: i64,
}
/// Partitioned result
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PartitionedResult {
    #[prost(int64, tag = "1")]
    pub schema: i64,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub partitions: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(int64, tag = "3")]
    pub rows_affected: i64,
}
/// Database handle
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseHandle {
    #[prost(int64, tag = "1")]
    pub id: i64,
    #[prost(int64, tag = "2")]
    pub magic: i64,
}
/// Connection handle
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionHandle {
    #[prost(int64, tag = "1")]
    pub id: i64,
    #[prost(int64, tag = "2")]
    pub magic: i64,
}
/// Statement handle
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementHandle {
    #[prost(int64, tag = "1")]
    pub id: i64,
    #[prost(int64, tag = "2")]
    pub magic: i64,
}
/// Arrow array stream pointer
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ArrowArrayStreamPtr {
    #[prost(bytes = "vec", tag = "1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// Arrow schema pointer
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ArrowSchemaPtr {
    #[prost(bytes = "vec", tag = "1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// Arrow array pointer
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ArrowArrayPtr {
    #[prost(bytes = "vec", tag = "1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseNewRequest {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseNewResponse {
    #[prost(message, optional, tag = "1")]
    pub db_handle: ::core::option::Option<DatabaseHandle>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseSetOptionStringRequest {
    #[prost(message, optional, tag = "1")]
    pub db_handle: ::core::option::Option<DatabaseHandle>,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseSetOptionStringResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseSetOptionBytesRequest {
    #[prost(message, optional, tag = "1")]
    pub db_handle: ::core::option::Option<DatabaseHandle>,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseSetOptionBytesResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseSetOptionIntRequest {
    #[prost(message, optional, tag = "1")]
    pub db_handle: ::core::option::Option<DatabaseHandle>,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub value: i64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseSetOptionIntResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseSetOptionDoubleRequest {
    #[prost(message, optional, tag = "1")]
    pub db_handle: ::core::option::Option<DatabaseHandle>,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(double, tag = "3")]
    pub value: f64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseSetOptionDoubleResponse {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseInitRequest {
    #[prost(message, optional, tag = "1")]
    pub db_handle: ::core::option::Option<DatabaseHandle>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseInitResponse {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseReleaseRequest {
    #[prost(message, optional, tag = "1")]
    pub db_handle: ::core::option::Option<DatabaseHandle>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseReleaseResponse {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionNewRequest {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionNewResponse {
    #[prost(message, optional, tag = "1")]
    pub conn_handle: ::core::option::Option<ConnectionHandle>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionSetOptionStringRequest {
    #[prost(message, optional, tag = "1")]
    pub conn_handle: ::core::option::Option<ConnectionHandle>,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionSetOptionStringResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionSetOptionBytesRequest {
    #[prost(message, optional, tag = "1")]
    pub conn_handle: ::core::option::Option<ConnectionHandle>,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionSetOptionBytesResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionSetOptionIntRequest {
    #[prost(message, optional, tag = "1")]
    pub conn_handle: ::core::option::Option<ConnectionHandle>,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub value: i64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionSetOptionIntResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectionSetOptionDoubleRequest {
    #[prost(message, optional, tag = "1")]
    pub conn_handle: ::core::option::Option<ConnectionHandle>,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(double, tag = "3")]
    pub value: f64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionSetOptionDoubleResponse {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionInitRequest {
    #[prost(message, optional, tag = "1")]
    pub conn_handle: ::core::option::Option<ConnectionHandle>,
    #[prost(message, optional, tag = "2")]
    pub db_handle: ::core::option::Option<DatabaseHandle>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionInitResponse {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionReleaseRequest {
    #[prost(message, optional, tag = "1")]
    pub conn_handle: ::core::option::Option<ConnectionHandle>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionReleaseResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionGetInfoRequest {
    #[prost(message, optional, tag = "1")]
    pub conn_handle: ::core::option::Option<ConnectionHandle>,
    #[prost(enumeration = "InfoCode", repeated, tag = "2")]
    pub info_codes: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionGetInfoResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub info_data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionGetObjectsRequest {
    #[prost(message, optional, tag = "1")]
    pub conn_handle: ::core::option::Option<ConnectionHandle>,
    #[prost(int32, tag = "2")]
    pub depth: i32,
    #[prost(string, optional, tag = "3")]
    pub catalog: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub db_schema: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub table_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "6")]
    pub table_type: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    pub column_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionGetObjectsResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub objects_data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionGetTableSchemaRequest {
    #[prost(message, optional, tag = "1")]
    pub conn_handle: ::core::option::Option<ConnectionHandle>,
    #[prost(string, optional, tag = "2")]
    pub catalog: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub db_schema: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub table_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionGetTableSchemaResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub schema_data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionGetTableTypesRequest {
    #[prost(message, optional, tag = "1")]
    pub conn_handle: ::core::option::Option<ConnectionHandle>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionGetTableTypesResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub table_types_data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionCommitRequest {
    #[prost(message, optional, tag = "1")]
    pub conn_handle: ::core::option::Option<ConnectionHandle>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionCommitResponse {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionRollbackRequest {
    #[prost(message, optional, tag = "1")]
    pub conn_handle: ::core::option::Option<ConnectionHandle>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionRollbackResponse {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementNewRequest {
    #[prost(message, optional, tag = "1")]
    pub conn_handle: ::core::option::Option<ConnectionHandle>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementNewResponse {
    #[prost(message, optional, tag = "1")]
    pub stmt_handle: ::core::option::Option<StatementHandle>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementReleaseRequest {
    #[prost(message, optional, tag = "1")]
    pub stmt_handle: ::core::option::Option<StatementHandle>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementReleaseResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementSetSqlQueryRequest {
    #[prost(message, optional, tag = "1")]
    pub stmt_handle: ::core::option::Option<StatementHandle>,
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementSetSqlQueryResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementSetSubstraitPlanRequest {
    #[prost(message, optional, tag = "1")]
    pub stmt_handle: ::core::option::Option<StatementHandle>,
    #[prost(bytes = "vec", tag = "2")]
    pub plan: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementSetSubstraitPlanResponse {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementPrepareRequest {
    #[prost(message, optional, tag = "1")]
    pub stmt_handle: ::core::option::Option<StatementHandle>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementPrepareResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementSetOptionStringRequest {
    #[prost(message, optional, tag = "1")]
    pub stmt_handle: ::core::option::Option<StatementHandle>,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementSetOptionStringResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementSetOptionBytesRequest {
    #[prost(message, optional, tag = "1")]
    pub stmt_handle: ::core::option::Option<StatementHandle>,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementSetOptionBytesResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementSetOptionIntRequest {
    #[prost(message, optional, tag = "1")]
    pub stmt_handle: ::core::option::Option<StatementHandle>,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub value: i64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementSetOptionIntResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatementSetOptionDoubleRequest {
    #[prost(message, optional, tag = "1")]
    pub stmt_handle: ::core::option::Option<StatementHandle>,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(double, tag = "3")]
    pub value: f64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementSetOptionDoubleResponse {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementGetParameterSchemaRequest {
    #[prost(message, optional, tag = "1")]
    pub stmt_handle: ::core::option::Option<StatementHandle>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementGetParameterSchemaResponse {
    #[prost(message, optional, tag = "1")]
    pub schema: ::core::option::Option<ArrowSchemaPtr>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementBindRequest {
    #[prost(message, optional, tag = "1")]
    pub stmt_handle: ::core::option::Option<StatementHandle>,
    #[prost(message, optional, tag = "2")]
    pub schema: ::core::option::Option<ArrowSchemaPtr>,
    #[prost(message, optional, tag = "3")]
    pub array: ::core::option::Option<ArrowArrayPtr>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementBindResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementBindStreamRequest {
    #[prost(message, optional, tag = "1")]
    pub stmt_handle: ::core::option::Option<StatementHandle>,
    #[prost(bytes = "vec", tag = "2")]
    pub stream: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementBindStreamResponse {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementExecuteQueryRequest {
    #[prost(message, optional, tag = "1")]
    pub stmt_handle: ::core::option::Option<StatementHandle>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementExecuteQueryResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<ExecuteResult>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementExecutePartitionsRequest {
    #[prost(message, optional, tag = "1")]
    pub stmt_handle: ::core::option::Option<StatementHandle>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementExecutePartitionsResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<PartitionedResult>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementReadPartitionRequest {
    #[prost(message, optional, tag = "1")]
    pub stmt_handle: ::core::option::Option<StatementHandle>,
    #[prost(bytes = "vec", tag = "2")]
    pub partition_descriptor: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatementReadPartitionResponse {
    #[prost(int64, tag = "1")]
    pub partition_stream: i64,
}
/// Status codes corresponding to Thrift StatusCode enum
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StatusCode {
    Unspecified = 0,
    Ok = 1,
    AuthenticationError = 2,
    NotImplemented = 3,
    NotFound = 4,
    AlreadyExists = 5,
    InvalidArgument = 6,
    InvalidState = 7,
    InvalidData = 8,
    Io = 9,
    Cancelled = 10,
    Unauthenticated = 11,
    Unauthorized = 12,
    GenericError = 13,
    InternalError = 14,
    MissingParameter = 15,
    InvalidParameterValue = 16,
    LoginError = 17,
}
impl StatusCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STATUS_CODE_UNSPECIFIED",
            Self::Ok => "STATUS_CODE_OK",
            Self::AuthenticationError => "STATUS_CODE_AUTHENTICATION_ERROR",
            Self::NotImplemented => "STATUS_CODE_NOT_IMPLEMENTED",
            Self::NotFound => "STATUS_CODE_NOT_FOUND",
            Self::AlreadyExists => "STATUS_CODE_ALREADY_EXISTS",
            Self::InvalidArgument => "STATUS_CODE_INVALID_ARGUMENT",
            Self::InvalidState => "STATUS_CODE_INVALID_STATE",
            Self::InvalidData => "STATUS_CODE_INVALID_DATA",
            Self::Io => "STATUS_CODE_IO",
            Self::Cancelled => "STATUS_CODE_CANCELLED",
            Self::Unauthenticated => "STATUS_CODE_UNAUTHENTICATED",
            Self::Unauthorized => "STATUS_CODE_UNAUTHORIZED",
            Self::GenericError => "STATUS_CODE_GENERIC_ERROR",
            Self::InternalError => "STATUS_CODE_INTERNAL_ERROR",
            Self::MissingParameter => "STATUS_CODE_MISSING_PARAMETER",
            Self::InvalidParameterValue => "STATUS_CODE_INVALID_PARAMETER_VALUE",
            Self::LoginError => "STATUS_CODE_LOGIN_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATUS_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "STATUS_CODE_OK" => Some(Self::Ok),
            "STATUS_CODE_AUTHENTICATION_ERROR" => Some(Self::AuthenticationError),
            "STATUS_CODE_NOT_IMPLEMENTED" => Some(Self::NotImplemented),
            "STATUS_CODE_NOT_FOUND" => Some(Self::NotFound),
            "STATUS_CODE_ALREADY_EXISTS" => Some(Self::AlreadyExists),
            "STATUS_CODE_INVALID_ARGUMENT" => Some(Self::InvalidArgument),
            "STATUS_CODE_INVALID_STATE" => Some(Self::InvalidState),
            "STATUS_CODE_INVALID_DATA" => Some(Self::InvalidData),
            "STATUS_CODE_IO" => Some(Self::Io),
            "STATUS_CODE_CANCELLED" => Some(Self::Cancelled),
            "STATUS_CODE_UNAUTHENTICATED" => Some(Self::Unauthenticated),
            "STATUS_CODE_UNAUTHORIZED" => Some(Self::Unauthorized),
            "STATUS_CODE_GENERIC_ERROR" => Some(Self::GenericError),
            "STATUS_CODE_INTERNAL_ERROR" => Some(Self::InternalError),
            "STATUS_CODE_MISSING_PARAMETER" => Some(Self::MissingParameter),
            "STATUS_CODE_INVALID_PARAMETER_VALUE" => Some(Self::InvalidParameterValue),
            "STATUS_CODE_LOGIN_ERROR" => Some(Self::LoginError),
            _ => None,
        }
    }
}
/// Info codes corresponding to Thrift InfoCode enum
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InfoCode {
    Unspecified = 0,
    VendorName = 1,
    VendorVersion = 2,
    VendorArrowVersion = 3,
    VendorSql = 101,
    VendorSubstrait = 102,
    VendorSubstraitMinVersion = 103,
    VendorSubstraitMaxVersion = 104,
    DriverName = 201,
    DriverVersion = 202,
    DriverArrowVersion = 203,
    DriverAdbcVersion = 204,
}
impl InfoCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INFO_CODE_UNSPECIFIED",
            Self::VendorName => "INFO_CODE_VENDOR_NAME",
            Self::VendorVersion => "INFO_CODE_VENDOR_VERSION",
            Self::VendorArrowVersion => "INFO_CODE_VENDOR_ARROW_VERSION",
            Self::VendorSql => "INFO_CODE_VENDOR_SQL",
            Self::VendorSubstrait => "INFO_CODE_VENDOR_SUBSTRAIT",
            Self::VendorSubstraitMinVersion => "INFO_CODE_VENDOR_SUBSTRAIT_MIN_VERSION",
            Self::VendorSubstraitMaxVersion => "INFO_CODE_VENDOR_SUBSTRAIT_MAX_VERSION",
            Self::DriverName => "INFO_CODE_DRIVER_NAME",
            Self::DriverVersion => "INFO_CODE_DRIVER_VERSION",
            Self::DriverArrowVersion => "INFO_CODE_DRIVER_ARROW_VERSION",
            Self::DriverAdbcVersion => "INFO_CODE_DRIVER_ADBC_VERSION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INFO_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "INFO_CODE_VENDOR_NAME" => Some(Self::VendorName),
            "INFO_CODE_VENDOR_VERSION" => Some(Self::VendorVersion),
            "INFO_CODE_VENDOR_ARROW_VERSION" => Some(Self::VendorArrowVersion),
            "INFO_CODE_VENDOR_SQL" => Some(Self::VendorSql),
            "INFO_CODE_VENDOR_SUBSTRAIT" => Some(Self::VendorSubstrait),
            "INFO_CODE_VENDOR_SUBSTRAIT_MIN_VERSION" => Some(Self::VendorSubstraitMinVersion),
            "INFO_CODE_VENDOR_SUBSTRAIT_MAX_VERSION" => Some(Self::VendorSubstraitMaxVersion),
            "INFO_CODE_DRIVER_NAME" => Some(Self::DriverName),
            "INFO_CODE_DRIVER_VERSION" => Some(Self::DriverVersion),
            "INFO_CODE_DRIVER_ARROW_VERSION" => Some(Self::DriverArrowVersion),
            "INFO_CODE_DRIVER_ADBC_VERSION" => Some(Self::DriverAdbcVersion),
            _ => None,
        }
    }
}

use prost::Message;
use proto_utils::*;
pub trait DatabaseDriver {
    fn database_new(input: DatabaseNewRequest) -> Result<DatabaseNewResponse, DriverException>;
    fn database_set_option_string(
        input: DatabaseSetOptionStringRequest,
    ) -> Result<DatabaseSetOptionStringResponse, DriverException>;
    fn database_set_option_bytes(
        input: DatabaseSetOptionBytesRequest,
    ) -> Result<DatabaseSetOptionBytesResponse, DriverException>;
    fn database_set_option_int(
        input: DatabaseSetOptionIntRequest,
    ) -> Result<DatabaseSetOptionIntResponse, DriverException>;
    fn database_set_option_double(
        input: DatabaseSetOptionDoubleRequest,
    ) -> Result<DatabaseSetOptionDoubleResponse, DriverException>;
    fn database_init(input: DatabaseInitRequest) -> Result<DatabaseInitResponse, DriverException>;
    fn database_release(
        input: DatabaseReleaseRequest,
    ) -> Result<DatabaseReleaseResponse, DriverException>;
    fn connection_new(
        input: ConnectionNewRequest,
    ) -> Result<ConnectionNewResponse, DriverException>;
    fn connection_set_option_string(
        input: ConnectionSetOptionStringRequest,
    ) -> Result<ConnectionSetOptionStringResponse, DriverException>;
    fn connection_set_option_bytes(
        input: ConnectionSetOptionBytesRequest,
    ) -> Result<ConnectionSetOptionBytesResponse, DriverException>;
    fn connection_set_option_int(
        input: ConnectionSetOptionIntRequest,
    ) -> Result<ConnectionSetOptionIntResponse, DriverException>;
    fn connection_set_option_double(
        input: ConnectionSetOptionDoubleRequest,
    ) -> Result<ConnectionSetOptionDoubleResponse, DriverException>;
    fn connection_init(
        input: ConnectionInitRequest,
    ) -> Result<ConnectionInitResponse, DriverException>;
    fn connection_release(
        input: ConnectionReleaseRequest,
    ) -> Result<ConnectionReleaseResponse, DriverException>;
    fn connection_get_info(
        input: ConnectionGetInfoRequest,
    ) -> Result<ConnectionGetInfoResponse, DriverException>;
    fn connection_get_objects(
        input: ConnectionGetObjectsRequest,
    ) -> Result<ConnectionGetObjectsResponse, DriverException>;
    fn connection_get_table_schema(
        input: ConnectionGetTableSchemaRequest,
    ) -> Result<ConnectionGetTableSchemaResponse, DriverException>;
    fn connection_get_table_types(
        input: ConnectionGetTableTypesRequest,
    ) -> Result<ConnectionGetTableTypesResponse, DriverException>;
    fn connection_commit(
        input: ConnectionCommitRequest,
    ) -> Result<ConnectionCommitResponse, DriverException>;
    fn connection_rollback(
        input: ConnectionRollbackRequest,
    ) -> Result<ConnectionRollbackResponse, DriverException>;
    fn statement_new(input: StatementNewRequest) -> Result<StatementNewResponse, DriverException>;
    fn statement_release(
        input: StatementReleaseRequest,
    ) -> Result<StatementReleaseResponse, DriverException>;
    fn statement_set_sql_query(
        input: StatementSetSqlQueryRequest,
    ) -> Result<StatementSetSqlQueryResponse, DriverException>;
    fn statement_set_substrait_plan(
        input: StatementSetSubstraitPlanRequest,
    ) -> Result<StatementSetSubstraitPlanResponse, DriverException>;
    fn statement_prepare(
        input: StatementPrepareRequest,
    ) -> Result<StatementPrepareResponse, DriverException>;
    fn statement_set_option_string(
        input: StatementSetOptionStringRequest,
    ) -> Result<StatementSetOptionStringResponse, DriverException>;
    fn statement_set_option_bytes(
        input: StatementSetOptionBytesRequest,
    ) -> Result<StatementSetOptionBytesResponse, DriverException>;
    fn statement_set_option_int(
        input: StatementSetOptionIntRequest,
    ) -> Result<StatementSetOptionIntResponse, DriverException>;
    fn statement_set_option_double(
        input: StatementSetOptionDoubleRequest,
    ) -> Result<StatementSetOptionDoubleResponse, DriverException>;
    fn statement_get_parameter_schema(
        input: StatementGetParameterSchemaRequest,
    ) -> Result<StatementGetParameterSchemaResponse, DriverException>;
    fn statement_bind(
        input: StatementBindRequest,
    ) -> Result<StatementBindResponse, DriverException>;
    fn statement_bind_stream(
        input: StatementBindStreamRequest,
    ) -> Result<StatementBindStreamResponse, DriverException>;
    fn statement_execute_query(
        input: StatementExecuteQueryRequest,
    ) -> Result<StatementExecuteQueryResponse, DriverException>;
    fn statement_execute_partitions(
        input: StatementExecutePartitionsRequest,
    ) -> Result<StatementExecutePartitionsResponse, DriverException>;
    fn statement_read_partition(
        input: StatementReadPartitionRequest,
    ) -> Result<StatementReadPartitionResponse, DriverException>;
}

pub trait DatabaseDriverServer: DatabaseDriver {
    fn handle_message(method: &str, message: Vec<u8>) -> Result<Vec<u8>, ProtoError<Vec<u8>>> {
        match method {
            "database_new" => {
                let input = match DatabaseNewRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::database_new(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "database_set_option_string" => {
                let input = match DatabaseSetOptionStringRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::database_set_option_string(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "database_set_option_bytes" => {
                let input = match DatabaseSetOptionBytesRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::database_set_option_bytes(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "database_set_option_int" => {
                let input = match DatabaseSetOptionIntRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::database_set_option_int(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "database_set_option_double" => {
                let input = match DatabaseSetOptionDoubleRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::database_set_option_double(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "database_init" => {
                let input = match DatabaseInitRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::database_init(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "database_release" => {
                let input = match DatabaseReleaseRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::database_release(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "connection_new" => {
                let input = match ConnectionNewRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::connection_new(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "connection_set_option_string" => {
                let input = match ConnectionSetOptionStringRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::connection_set_option_string(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "connection_set_option_bytes" => {
                let input = match ConnectionSetOptionBytesRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::connection_set_option_bytes(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "connection_set_option_int" => {
                let input = match ConnectionSetOptionIntRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::connection_set_option_int(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "connection_set_option_double" => {
                let input = match ConnectionSetOptionDoubleRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::connection_set_option_double(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "connection_init" => {
                let input = match ConnectionInitRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::connection_init(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "connection_release" => {
                let input = match ConnectionReleaseRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::connection_release(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "connection_get_info" => {
                let input = match ConnectionGetInfoRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::connection_get_info(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "connection_get_objects" => {
                let input = match ConnectionGetObjectsRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::connection_get_objects(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "connection_get_table_schema" => {
                let input = match ConnectionGetTableSchemaRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::connection_get_table_schema(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "connection_get_table_types" => {
                let input = match ConnectionGetTableTypesRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::connection_get_table_types(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "connection_commit" => {
                let input = match ConnectionCommitRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::connection_commit(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "connection_rollback" => {
                let input = match ConnectionRollbackRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::connection_rollback(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "statement_new" => {
                let input = match StatementNewRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::statement_new(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "statement_release" => {
                let input = match StatementReleaseRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::statement_release(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "statement_set_sql_query" => {
                let input = match StatementSetSqlQueryRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::statement_set_sql_query(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "statement_set_substrait_plan" => {
                let input = match StatementSetSubstraitPlanRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::statement_set_substrait_plan(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "statement_prepare" => {
                let input = match StatementPrepareRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::statement_prepare(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "statement_set_option_string" => {
                let input = match StatementSetOptionStringRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::statement_set_option_string(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "statement_set_option_bytes" => {
                let input = match StatementSetOptionBytesRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::statement_set_option_bytes(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "statement_set_option_int" => {
                let input = match StatementSetOptionIntRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::statement_set_option_int(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "statement_set_option_double" => {
                let input = match StatementSetOptionDoubleRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::statement_set_option_double(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "statement_get_parameter_schema" => {
                let input = match StatementGetParameterSchemaRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::statement_get_parameter_schema(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "statement_bind" => {
                let input = match StatementBindRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::statement_bind(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "statement_bind_stream" => {
                let input = match StatementBindStreamRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::statement_bind_stream(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "statement_execute_query" => {
                let input = match StatementExecuteQueryRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::statement_execute_query(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "statement_execute_partitions" => {
                let input = match StatementExecutePartitionsRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::statement_execute_partitions(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            "statement_read_partition" => {
                let input = match StatementReadPartitionRequest::decode(&message[..]) {
                    Ok(input) => input,
                    Err(e) => return Err(ProtoError::Transport(e.to_string())),
                };
                let result = Self::statement_read_partition(input);
                match result {
                    Ok(output) => Ok(output.encode_to_vec()),
                    Err(e) => Err(ProtoError::Application(e.encode_to_vec())),
                }
            }
            _ => Err(ProtoError::Transport(format!("Unknown method: {}", method))),
        }
    }
}
pub struct DatabaseDriverClient<T: Transport> {
    _marker: ::core::marker::PhantomData<T>,
}
impl<T: Transport> DatabaseDriverClient<T> {
    pub fn database_new(
        input: DatabaseNewRequest,
    ) -> Result<DatabaseNewResponse, ProtoError<DriverException>> {
        let result = T::handle_message("DatabaseDriver", "database_new", input.encode_to_vec());
        match result {
            Ok(output) => {
                let output = DatabaseNewResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn database_set_option_string(
        input: DatabaseSetOptionStringRequest,
    ) -> Result<DatabaseSetOptionStringResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "database_set_option_string",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = DatabaseSetOptionStringResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn database_set_option_bytes(
        input: DatabaseSetOptionBytesRequest,
    ) -> Result<DatabaseSetOptionBytesResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "database_set_option_bytes",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = DatabaseSetOptionBytesResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn database_set_option_int(
        input: DatabaseSetOptionIntRequest,
    ) -> Result<DatabaseSetOptionIntResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "database_set_option_int",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = DatabaseSetOptionIntResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn database_set_option_double(
        input: DatabaseSetOptionDoubleRequest,
    ) -> Result<DatabaseSetOptionDoubleResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "database_set_option_double",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = DatabaseSetOptionDoubleResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn database_init(
        input: DatabaseInitRequest,
    ) -> Result<DatabaseInitResponse, ProtoError<DriverException>> {
        let result = T::handle_message("DatabaseDriver", "database_init", input.encode_to_vec());
        match result {
            Ok(output) => {
                let output = DatabaseInitResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn database_release(
        input: DatabaseReleaseRequest,
    ) -> Result<DatabaseReleaseResponse, ProtoError<DriverException>> {
        let result = T::handle_message("DatabaseDriver", "database_release", input.encode_to_vec());
        match result {
            Ok(output) => {
                let output = DatabaseReleaseResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn connection_new(
        input: ConnectionNewRequest,
    ) -> Result<ConnectionNewResponse, ProtoError<DriverException>> {
        let result = T::handle_message("DatabaseDriver", "connection_new", input.encode_to_vec());
        match result {
            Ok(output) => {
                let output = ConnectionNewResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn connection_set_option_string(
        input: ConnectionSetOptionStringRequest,
    ) -> Result<ConnectionSetOptionStringResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "connection_set_option_string",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = ConnectionSetOptionStringResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn connection_set_option_bytes(
        input: ConnectionSetOptionBytesRequest,
    ) -> Result<ConnectionSetOptionBytesResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "connection_set_option_bytes",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = ConnectionSetOptionBytesResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn connection_set_option_int(
        input: ConnectionSetOptionIntRequest,
    ) -> Result<ConnectionSetOptionIntResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "connection_set_option_int",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = ConnectionSetOptionIntResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn connection_set_option_double(
        input: ConnectionSetOptionDoubleRequest,
    ) -> Result<ConnectionSetOptionDoubleResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "connection_set_option_double",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = ConnectionSetOptionDoubleResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn connection_init(
        input: ConnectionInitRequest,
    ) -> Result<ConnectionInitResponse, ProtoError<DriverException>> {
        let result = T::handle_message("DatabaseDriver", "connection_init", input.encode_to_vec());
        match result {
            Ok(output) => {
                let output = ConnectionInitResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn connection_release(
        input: ConnectionReleaseRequest,
    ) -> Result<ConnectionReleaseResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "connection_release",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = ConnectionReleaseResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn connection_get_info(
        input: ConnectionGetInfoRequest,
    ) -> Result<ConnectionGetInfoResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "connection_get_info",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = ConnectionGetInfoResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn connection_get_objects(
        input: ConnectionGetObjectsRequest,
    ) -> Result<ConnectionGetObjectsResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "connection_get_objects",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = ConnectionGetObjectsResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn connection_get_table_schema(
        input: ConnectionGetTableSchemaRequest,
    ) -> Result<ConnectionGetTableSchemaResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "connection_get_table_schema",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = ConnectionGetTableSchemaResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn connection_get_table_types(
        input: ConnectionGetTableTypesRequest,
    ) -> Result<ConnectionGetTableTypesResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "connection_get_table_types",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = ConnectionGetTableTypesResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn connection_commit(
        input: ConnectionCommitRequest,
    ) -> Result<ConnectionCommitResponse, ProtoError<DriverException>> {
        let result =
            T::handle_message("DatabaseDriver", "connection_commit", input.encode_to_vec());
        match result {
            Ok(output) => {
                let output = ConnectionCommitResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn connection_rollback(
        input: ConnectionRollbackRequest,
    ) -> Result<ConnectionRollbackResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "connection_rollback",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = ConnectionRollbackResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn statement_new(
        input: StatementNewRequest,
    ) -> Result<StatementNewResponse, ProtoError<DriverException>> {
        let result = T::handle_message("DatabaseDriver", "statement_new", input.encode_to_vec());
        match result {
            Ok(output) => {
                let output = StatementNewResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn statement_release(
        input: StatementReleaseRequest,
    ) -> Result<StatementReleaseResponse, ProtoError<DriverException>> {
        let result =
            T::handle_message("DatabaseDriver", "statement_release", input.encode_to_vec());
        match result {
            Ok(output) => {
                let output = StatementReleaseResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn statement_set_sql_query(
        input: StatementSetSqlQueryRequest,
    ) -> Result<StatementSetSqlQueryResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "statement_set_sql_query",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = StatementSetSqlQueryResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn statement_set_substrait_plan(
        input: StatementSetSubstraitPlanRequest,
    ) -> Result<StatementSetSubstraitPlanResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "statement_set_substrait_plan",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = StatementSetSubstraitPlanResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn statement_prepare(
        input: StatementPrepareRequest,
    ) -> Result<StatementPrepareResponse, ProtoError<DriverException>> {
        let result =
            T::handle_message("DatabaseDriver", "statement_prepare", input.encode_to_vec());
        match result {
            Ok(output) => {
                let output = StatementPrepareResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn statement_set_option_string(
        input: StatementSetOptionStringRequest,
    ) -> Result<StatementSetOptionStringResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "statement_set_option_string",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = StatementSetOptionStringResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn statement_set_option_bytes(
        input: StatementSetOptionBytesRequest,
    ) -> Result<StatementSetOptionBytesResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "statement_set_option_bytes",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = StatementSetOptionBytesResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn statement_set_option_int(
        input: StatementSetOptionIntRequest,
    ) -> Result<StatementSetOptionIntResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "statement_set_option_int",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = StatementSetOptionIntResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn statement_set_option_double(
        input: StatementSetOptionDoubleRequest,
    ) -> Result<StatementSetOptionDoubleResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "statement_set_option_double",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = StatementSetOptionDoubleResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn statement_get_parameter_schema(
        input: StatementGetParameterSchemaRequest,
    ) -> Result<StatementGetParameterSchemaResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "statement_get_parameter_schema",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = StatementGetParameterSchemaResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn statement_bind(
        input: StatementBindRequest,
    ) -> Result<StatementBindResponse, ProtoError<DriverException>> {
        let result = T::handle_message("DatabaseDriver", "statement_bind", input.encode_to_vec());
        match result {
            Ok(output) => {
                let output = StatementBindResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn statement_bind_stream(
        input: StatementBindStreamRequest,
    ) -> Result<StatementBindStreamResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "statement_bind_stream",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = StatementBindStreamResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn statement_execute_query(
        input: StatementExecuteQueryRequest,
    ) -> Result<StatementExecuteQueryResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "statement_execute_query",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = StatementExecuteQueryResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn statement_execute_partitions(
        input: StatementExecutePartitionsRequest,
    ) -> Result<StatementExecutePartitionsResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "statement_execute_partitions",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = StatementExecutePartitionsResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }

    pub fn statement_read_partition(
        input: StatementReadPartitionRequest,
    ) -> Result<StatementReadPartitionResponse, ProtoError<DriverException>> {
        let result = T::handle_message(
            "DatabaseDriver",
            "statement_read_partition",
            input.encode_to_vec(),
        );
        match result {
            Ok(output) => {
                let output = StatementReadPartitionResponse::decode(&output[..]);
                match output {
                    Ok(output) => Ok(output),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Application(e)) => {
                let output = DriverException::decode(&e[..]);
                match output {
                    Ok(output) => Err(ProtoError::Application(output)),
                    Err(e) => Err(ProtoError::Transport(e.to_string())),
                }
            }
            Err(ProtoError::Transport(e)) => Err(ProtoError::Transport(e)),
        }
    }
}
