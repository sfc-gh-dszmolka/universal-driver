#
# Autogenerated by Thrift Compiler (0.22.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys

from thrift.transport import TTransport
all_structs = []


class StatusCode(object):
    OK = 0
    AUTHENTICATION_ERROR = 1
    NOT_IMPLEMENTED = 2
    NOT_FOUND = 3
    ALREADY_EXISTS = 4
    INVALID_ARGUMENT = 5
    INVALID_STATE = 6
    INVALID_DATA = 7
    IO = 8
    CANCELLED = 9
    UNAUTHENTICATED = 10
    UNAUTHORIZED = 11
    GENERIC_ERROR = 12
    INTERNAL_ERROR = 13
    MISSING_PARAMETER = 14
    INVALID_PARAMETER_VALUE = 15
    LOGIN_ERROR = 16

    _VALUES_TO_NAMES = {
        0: "OK",
        1: "AUTHENTICATION_ERROR",
        2: "NOT_IMPLEMENTED",
        3: "NOT_FOUND",
        4: "ALREADY_EXISTS",
        5: "INVALID_ARGUMENT",
        6: "INVALID_STATE",
        7: "INVALID_DATA",
        8: "IO",
        9: "CANCELLED",
        10: "UNAUTHENTICATED",
        11: "UNAUTHORIZED",
        12: "GENERIC_ERROR",
        13: "INTERNAL_ERROR",
        14: "MISSING_PARAMETER",
        15: "INVALID_PARAMETER_VALUE",
        16: "LOGIN_ERROR",
    }

    _NAMES_TO_VALUES = {
        "OK": 0,
        "AUTHENTICATION_ERROR": 1,
        "NOT_IMPLEMENTED": 2,
        "NOT_FOUND": 3,
        "ALREADY_EXISTS": 4,
        "INVALID_ARGUMENT": 5,
        "INVALID_STATE": 6,
        "INVALID_DATA": 7,
        "IO": 8,
        "CANCELLED": 9,
        "UNAUTHENTICATED": 10,
        "UNAUTHORIZED": 11,
        "GENERIC_ERROR": 12,
        "INTERNAL_ERROR": 13,
        "MISSING_PARAMETER": 14,
        "INVALID_PARAMETER_VALUE": 15,
        "LOGIN_ERROR": 16,
    }


class InfoCode(object):
    VENDOR_NAME = 0
    VENDOR_VERSION = 1
    VENDOR_ARROW_VERSION = 2
    VENDOR_SQL = 100
    VENDOR_SUBSTRAIT = 101
    VENDOR_SUBSTRAIT_MIN_VERSION = 102
    VENDOR_SUBSTRAIT_MAX_VERSION = 103
    DRIVER_NAME = 200
    DRIVER_VERSION = 201
    DRIVER_ARROW_VERSION = 202
    DRIVER_ADBC_VERSION = 203

    _VALUES_TO_NAMES = {
        0: "VENDOR_NAME",
        1: "VENDOR_VERSION",
        2: "VENDOR_ARROW_VERSION",
        100: "VENDOR_SQL",
        101: "VENDOR_SUBSTRAIT",
        102: "VENDOR_SUBSTRAIT_MIN_VERSION",
        103: "VENDOR_SUBSTRAIT_MAX_VERSION",
        200: "DRIVER_NAME",
        201: "DRIVER_VERSION",
        202: "DRIVER_ARROW_VERSION",
        203: "DRIVER_ADBC_VERSION",
    }

    _NAMES_TO_VALUES = {
        "VENDOR_NAME": 0,
        "VENDOR_VERSION": 1,
        "VENDOR_ARROW_VERSION": 2,
        "VENDOR_SQL": 100,
        "VENDOR_SUBSTRAIT": 101,
        "VENDOR_SUBSTRAIT_MIN_VERSION": 102,
        "VENDOR_SUBSTRAIT_MAX_VERSION": 103,
        "DRIVER_NAME": 200,
        "DRIVER_VERSION": 201,
        "DRIVER_ARROW_VERSION": 202,
        "DRIVER_ADBC_VERSION": 203,
    }


class ErrorDetail(object):
    """
    Attributes:
     - key
     - value

    """
    thrift_spec = None


    def __init__(self, key = None, value = None,):
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ErrorDetail')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AuthenticationError(object):
    """
    Attributes:
     - detail

    """
    thrift_spec = None


    def __init__(self, detail = None,):
        self.detail = detail

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.detail = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AuthenticationError')
        if self.detail is not None:
            oprot.writeFieldBegin('detail', TType.STRING, 1)
            oprot.writeString(self.detail.encode('utf-8') if sys.version_info[0] == 2 else self.detail)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.detail is None:
            raise TProtocolException(message='Required field detail is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GenericError(object):
    thrift_spec = None


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GenericError')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InternalError(object):
    thrift_spec = None


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InternalError')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LoginError(object):
    """
    Attributes:
     - message
     - code

    """
    thrift_spec = None


    def __init__(self, message = None, code = None,):
        self.message = message
        self.code = code

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoginError')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 2)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.message is None:
            raise TProtocolException(message='Required field message is unset!')
        if self.code is None:
            raise TProtocolException(message='Required field code is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MissingParameter(object):
    """
    Attributes:
     - parameter

    """
    thrift_spec = None


    def __init__(self, parameter = None,):
        self.parameter = parameter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.parameter = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MissingParameter')
        if self.parameter is not None:
            oprot.writeFieldBegin('parameter', TType.STRING, 1)
            oprot.writeString(self.parameter.encode('utf-8') if sys.version_info[0] == 2 else self.parameter)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.parameter is None:
            raise TProtocolException(message='Required field parameter is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidParameterValue(object):
    """
    Attributes:
     - parameter
     - value
     - explanation

    """
    thrift_spec = None


    def __init__(self, parameter = None, value = None, explanation = None,):
        self.parameter = parameter
        self.value = value
        self.explanation = explanation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.parameter = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.explanation = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidParameterValue')
        if self.parameter is not None:
            oprot.writeFieldBegin('parameter', TType.STRING, 1)
            oprot.writeString(self.parameter.encode('utf-8') if sys.version_info[0] == 2 else self.parameter)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        if self.explanation is not None:
            oprot.writeFieldBegin('explanation', TType.STRING, 3)
            oprot.writeString(self.explanation.encode('utf-8') if sys.version_info[0] == 2 else self.explanation)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.parameter is None:
            raise TProtocolException(message='Required field parameter is unset!')
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DriverError(object):
    """
    Attributes:
     - authError
     - genericError
     - internalError
     - missingParameter
     - invalidParameterValue
     - loginError

    """
    thrift_spec = None


    def __init__(self, authError = None, genericError = None, internalError = None, missingParameter = None, invalidParameterValue = None, loginError = None,):
        self.authError = authError
        self.genericError = genericError
        self.internalError = internalError
        self.missingParameter = missingParameter
        self.invalidParameterValue = invalidParameterValue
        self.loginError = loginError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.authError = AuthenticationError()
                    self.authError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.genericError = GenericError()
                    self.genericError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.internalError = InternalError()
                    self.internalError.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.missingParameter = MissingParameter()
                    self.missingParameter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.invalidParameterValue = InvalidParameterValue()
                    self.invalidParameterValue.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.loginError = LoginError()
                    self.loginError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DriverError')
        if self.authError is not None:
            oprot.writeFieldBegin('authError', TType.STRUCT, 1)
            self.authError.write(oprot)
            oprot.writeFieldEnd()
        if self.genericError is not None:
            oprot.writeFieldBegin('genericError', TType.STRUCT, 2)
            self.genericError.write(oprot)
            oprot.writeFieldEnd()
        if self.internalError is not None:
            oprot.writeFieldBegin('internalError', TType.STRUCT, 3)
            self.internalError.write(oprot)
            oprot.writeFieldEnd()
        if self.missingParameter is not None:
            oprot.writeFieldBegin('missingParameter', TType.STRUCT, 4)
            self.missingParameter.write(oprot)
            oprot.writeFieldEnd()
        if self.invalidParameterValue is not None:
            oprot.writeFieldBegin('invalidParameterValue', TType.STRUCT, 5)
            self.invalidParameterValue.write(oprot)
            oprot.writeFieldEnd()
        if self.loginError is not None:
            oprot.writeFieldBegin('loginError', TType.STRUCT, 6)
            self.loginError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DriverException(TException):
    """
    Attributes:
     - message
     - status_code
     - error
     - report

    """
    thrift_spec = None


    def __init__(self, message = None, status_code = None, error = None, report = None,):
        super(DriverException, self).__setattr__('message', message)
        super(DriverException, self).__setattr__('status_code', status_code)
        super(DriverException, self).__setattr__('error', error)
        super(DriverException, self).__setattr__('report', report)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, self.status_code, self.error, self.report, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        status_code = None
        error = None
        report = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    status_code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    error = DriverError()
                    error.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    report = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
            status_code=status_code,
            error=error,
            report=report,
        )

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DriverException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.status_code is not None:
            oprot.writeFieldBegin('status_code', TType.I32, 2)
            oprot.writeI32(self.status_code)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 3)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        if self.report is not None:
            oprot.writeFieldBegin('report', TType.STRING, 4)
            oprot.writeString(self.report.encode('utf-8') if sys.version_info[0] == 2 else self.report)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.message is None:
            raise TProtocolException(message='Required field message is unset!')
        if self.status_code is None:
            raise TProtocolException(message='Required field status_code is unset!')
        if self.error is None:
            raise TProtocolException(message='Required field error is unset!')
        if self.report is None:
            raise TProtocolException(message='Required field report is unset!')
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExecuteResult(object):
    """
    Attributes:
     - stream
     - rows_affected

    """
    thrift_spec = None


    def __init__(self, stream = None, rows_affected = None,):
        self.stream = stream
        self.rows_affected = rows_affected

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stream = ArrowArrayStreamPtr()
                    self.stream.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.rows_affected = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExecuteResult')
        if self.stream is not None:
            oprot.writeFieldBegin('stream', TType.STRUCT, 1)
            self.stream.write(oprot)
            oprot.writeFieldEnd()
        if self.rows_affected is not None:
            oprot.writeFieldBegin('rows_affected', TType.I64, 2)
            oprot.writeI64(self.rows_affected)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.stream is None:
            raise TProtocolException(message='Required field stream is unset!')
        if self.rows_affected is None:
            raise TProtocolException(message='Required field rows_affected is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PartitionedResult(object):
    """
    Attributes:
     - schema
     - partitions
     - rows_affected

    """
    thrift_spec = None


    def __init__(self, schema = None, partitions = None, rows_affected = None,):
        self.schema = schema
        self.partitions = partitions
        self.rows_affected = rows_affected

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.schema = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partitions = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readBinary()
                        self.partitions.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.rows_affected = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PartitionedResult')
        if self.schema is not None:
            oprot.writeFieldBegin('schema', TType.I64, 1)
            oprot.writeI64(self.schema)
            oprot.writeFieldEnd()
        if self.partitions is not None:
            oprot.writeFieldBegin('partitions', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.partitions))
            for iter6 in self.partitions:
                oprot.writeBinary(iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rows_affected is not None:
            oprot.writeFieldBegin('rows_affected', TType.I64, 3)
            oprot.writeI64(self.rows_affected)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.schema is None:
            raise TProtocolException(message='Required field schema is unset!')
        if self.partitions is None:
            raise TProtocolException(message='Required field partitions is unset!')
        if self.rows_affected is None:
            raise TProtocolException(message='Required field rows_affected is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DatabaseHandle(object):
    """
    Attributes:
     - id
     - magic

    """
    thrift_spec = None


    def __init__(self, id = None, magic = None,):
        self.id = id
        self.magic = magic

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.magic = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DatabaseHandle')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.magic is not None:
            oprot.writeFieldBegin('magic', TType.I64, 2)
            oprot.writeI64(self.magic)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.magic is None:
            raise TProtocolException(message='Required field magic is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConnectionHandle(object):
    """
    Attributes:
     - id
     - magic

    """
    thrift_spec = None


    def __init__(self, id = None, magic = None,):
        self.id = id
        self.magic = magic

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.magic = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConnectionHandle')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.magic is not None:
            oprot.writeFieldBegin('magic', TType.I64, 2)
            oprot.writeI64(self.magic)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.magic is None:
            raise TProtocolException(message='Required field magic is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StatementHandle(object):
    """
    Attributes:
     - id
     - magic

    """
    thrift_spec = None


    def __init__(self, id = None, magic = None,):
        self.id = id
        self.magic = magic

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.magic = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StatementHandle')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.magic is not None:
            oprot.writeFieldBegin('magic', TType.I64, 2)
            oprot.writeI64(self.magic)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        if self.magic is None:
            raise TProtocolException(message='Required field magic is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ArrowArrayStreamPtr(object):
    """
    Attributes:
     - value

    """
    thrift_spec = None


    def __init__(self, value = None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ArrowArrayStreamPtr')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 1)
            oprot.writeBinary(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ArrowSchemaPtr(object):
    """
    Attributes:
     - value

    """
    thrift_spec = None


    def __init__(self, value = None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ArrowSchemaPtr')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 1)
            oprot.writeBinary(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ArrowArrayPtr(object):
    """
    Attributes:
     - value

    """
    thrift_spec = None


    def __init__(self, value = None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ArrowArrayPtr')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 1)
            oprot.writeBinary(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ErrorDetail)
ErrorDetail.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'value', 'UTF8', None, ),  # 2
)
all_structs.append(AuthenticationError)
AuthenticationError.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'detail', 'UTF8', None, ),  # 1
)
all_structs.append(GenericError)
GenericError.thrift_spec = (
)
all_structs.append(InternalError)
InternalError.thrift_spec = (
)
all_structs.append(LoginError)
LoginError.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
    (2, TType.I32, 'code', None, None, ),  # 2
)
all_structs.append(MissingParameter)
MissingParameter.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'parameter', 'UTF8', None, ),  # 1
)
all_structs.append(InvalidParameterValue)
InvalidParameterValue.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'parameter', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'value', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'explanation', 'UTF8', None, ),  # 3
)
all_structs.append(DriverError)
DriverError.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'authError', [AuthenticationError, None], None, ),  # 1
    (2, TType.STRUCT, 'genericError', [GenericError, None], None, ),  # 2
    (3, TType.STRUCT, 'internalError', [InternalError, None], None, ),  # 3
    (4, TType.STRUCT, 'missingParameter', [MissingParameter, None], None, ),  # 4
    (5, TType.STRUCT, 'invalidParameterValue', [InvalidParameterValue, None], None, ),  # 5
    (6, TType.STRUCT, 'loginError', [LoginError, None], None, ),  # 6
)
all_structs.append(DriverException)
DriverException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
    (2, TType.I32, 'status_code', None, None, ),  # 2
    (3, TType.STRUCT, 'error', [DriverError, None], None, ),  # 3
    (4, TType.STRING, 'report', 'UTF8', None, ),  # 4
)
all_structs.append(ExecuteResult)
ExecuteResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stream', [ArrowArrayStreamPtr, None], None, ),  # 1
    (2, TType.I64, 'rows_affected', None, None, ),  # 2
)
all_structs.append(PartitionedResult)
PartitionedResult.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'schema', None, None, ),  # 1
    (2, TType.LIST, 'partitions', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.I64, 'rows_affected', None, None, ),  # 3
)
all_structs.append(DatabaseHandle)
DatabaseHandle.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.I64, 'magic', None, None, ),  # 2
)
all_structs.append(ConnectionHandle)
ConnectionHandle.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.I64, 'magic', None, None, ),  # 2
)
all_structs.append(StatementHandle)
StatementHandle.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.I64, 'magic', None, None, ),  # 2
)
all_structs.append(ArrowArrayStreamPtr)
ArrowArrayStreamPtr.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'value', 'BINARY', None, ),  # 1
)
all_structs.append(ArrowSchemaPtr)
ArrowSchemaPtr.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'value', 'BINARY', None, ),  # 1
)
all_structs.append(ArrowArrayPtr)
ArrowArrayPtr.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'value', 'BINARY', None, ),  # 1
)
fix_spec(all_structs)
del all_structs
