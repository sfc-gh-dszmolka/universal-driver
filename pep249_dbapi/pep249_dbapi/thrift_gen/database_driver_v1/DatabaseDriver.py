#
# Autogenerated by Thrift Compiler (0.22.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def databaseNew(self):
        """
        Create a new, uninitialized database object.
        Corresponds to AdbcDatabaseNew.
        @return An opaque handle to the server-side database object.

        """
        pass

    def databaseSetOptionString(self, db_handle, key, value):
        """
        Set a string-valued option for a database.
        Corresponds to AdbcDatabaseSetOption.

        Parameters:
         - db_handle
         - key
         - value

        """
        pass

    def databaseSetOptionBytes(self, db_handle, key, value):
        """
        Set a byte-valued option for a database.
        Corresponds to AdbcDatabaseSetOptionBytes.

        Parameters:
         - db_handle
         - key
         - value

        """
        pass

    def databaseSetOptionInt(self, db_handle, key, value):
        """
        Set an integer-valued option for a database.
        Corresponds to AdbcDatabaseSetOptionInt.

        Parameters:
         - db_handle
         - key
         - value

        """
        pass

    def databaseSetOptionDouble(self, db_handle, key, value):
        """
        Set a double-valued option for a database.
        Corresponds to AdbcDatabaseSetOptionDouble.

        Parameters:
         - db_handle
         - key
         - value

        """
        pass

    def databaseInit(self, db_handle):
        """
        Finalize database initialization.
        Corresponds to AdbcDatabaseInit.

        Parameters:
         - db_handle

        """
        pass

    def databaseRelease(self, db_handle):
        """
        Release the database object and its resources. The handle is invalidated.
        Corresponds to AdbcDatabaseRelease.

        Parameters:
         - db_handle

        """
        pass

    def connectionNew(self):
        """
        Create a new, uninitialized connection object.
        Corresponds to AdbcConnectionNew.
        @return An opaque handle to the server-side connection object.

        """
        pass

    def connectionSetOptionString(self, conn_handle, key, value):
        """
        Set a string-valued option for a connection.
        Corresponds to AdbcConnectionSetOption.

        Parameters:
         - conn_handle
         - key
         - value

        """
        pass

    def connectionSetOptionBytes(self, conn_handle, key, value):
        """
        Set a byte-valued option for a connection.
        Corresponds to AdbcConnectionSetOptionBytes.

        Parameters:
         - conn_handle
         - key
         - value

        """
        pass

    def connectionSetOptionInt(self, conn_handle, key, value):
        """
        Set an integer-valued option for a connection.
        Corresponds to AdbcConnectionSetOptionInt.

        Parameters:
         - conn_handle
         - key
         - value

        """
        pass

    def connectionSetOptionDouble(self, conn_handle, key, value):
        """
        Set a double-valued option for a connection.
        Corresponds to AdbcConnectionSetOptionDouble.

        Parameters:
         - conn_handle
         - key
         - value

        """
        pass

    def connectionInit(self, conn_handle, db_handle):
        """
        Finalize connection initialization.
        Corresponds to AdbcConnectionInit.

        Parameters:
         - conn_handle
         - db_handle

        """
        pass

    def connectionRelease(self, conn_handle):
        """
        Release the connection object and its resources. The handle is invalidated.
        Corresponds to AdbcConnectionRelease.

        Parameters:
         - conn_handle

        """
        pass

    def connectionGetInfo(self, conn_handle, info_codes):
        """
        Get metadata about the database/driver.
        Corresponds to AdbcConnectionGetInfo.
        @param info_codes A list of codes for the metadata to retrieve. If null/empty, retrieve all.
        @return An Arrow IPC stream containing the metadata.

        Parameters:
         - conn_handle
         - info_codes

        """
        pass

    def connectionGetObjects(self, conn_handle, depth, catalog, db_schema, table_name, table_type, column_name):
        """
        Get a hierarchical view of catalogs, DB schemas, tables, and columns.
        Corresponds to AdbcConnectionGetObjects.
        @return An Arrow IPC stream containing the metadata.

        Parameters:
         - conn_handle
         - depth
         - catalog
         - db_schema
         - table_name
         - table_type
         - column_name

        """
        pass

    def connectionGetTableSchema(self, conn_handle, catalog, db_schema, table_name):
        """
        Get the Arrow schema of a table.
        Corresponds to AdbcConnectionGetTableSchema.
        @return A serialized ArrowSchema in IPC format.

        Parameters:
         - conn_handle
         - catalog
         - db_schema
         - table_name

        """
        pass

    def connectionGetTableTypes(self, conn_handle):
        """
        Get a list of table types in the database.
        Corresponds to AdbcConnectionGetTableTypes.
        @return An Arrow IPC stream containing the table types.

        Parameters:
         - conn_handle

        """
        pass

    def connectionCommit(self, conn_handle):
        """
        Commit any pending transactions.
        Corresponds to AdbcConnectionCommit.

        Parameters:
         - conn_handle

        """
        pass

    def connectionRollback(self, conn_handle):
        """
        Roll back any pending transactions.
        Corresponds to AdbcConnectionRollback.

        Parameters:
         - conn_handle

        """
        pass

    def statementNew(self, conn_handle):
        """
        Create a new statement.
        Corresponds to AdbcStatementNew.
        @return An opaque handle to the server-side statement object.

        Parameters:
         - conn_handle

        """
        pass

    def statementRelease(self, stmt_handle):
        """
        Release the statement object.
        Corresponds to AdbcStatementRelease.

        Parameters:
         - stmt_handle

        """
        pass

    def statementSetSqlQuery(self, stmt_handle, query):
        """
        Set the SQL query to execute.
        Corresponds to AdbcStatementSetSqlQuery.

        Parameters:
         - stmt_handle
         - query

        """
        pass

    def statementSetSubstraitPlan(self, stmt_handle, plan):
        """
        Set the Substrait plan to execute.
        Corresponds to AdbcStatementSetSubstraitPlan.

        Parameters:
         - stmt_handle
         - plan

        """
        pass

    def statementPrepare(self, stmt_handle):
        """
        Prepare a statement for execution.
        Corresponds to AdbcStatementPrepare.

        Parameters:
         - stmt_handle

        """
        pass

    def statementSetOptionString(self, stmt_handle, key, value):
        """
        Set a string-valued option for a statement.
        Corresponds to AdbcStatementSetOption.

        Parameters:
         - stmt_handle
         - key
         - value

        """
        pass

    def statementSetOptionBytes(self, stmt_handle, key, value):
        """
        Set a byte-valued option for a statement.
        Corresponds to AdbcStatementSetOptionBytes.

        Parameters:
         - stmt_handle
         - key
         - value

        """
        pass

    def statementSetOptionInt(self, stmt_handle, key, value):
        """
        Set an integer-valued option for a statement.
        Corresponds to AdbcStatementSetOptionInt.

        Parameters:
         - stmt_handle
         - key
         - value

        """
        pass

    def statementSetOptionDouble(self, stmt_handle, key, value):
        """
        Set a double-valued option for a statement.
        Corresponds to AdbcStatementSetOptionDouble.

        Parameters:
         - stmt_handle
         - key
         - value

        """
        pass

    def statementGetParameterSchema(self, stmt_handle):
        """
        Get the schema for the parameters of a prepared statement.
        Corresponds to AdbcStatementGetParameterSchema.
        @return A serialized ArrowSchema in IPC format.

        Parameters:
         - stmt_handle

        """
        pass

    def statementBind(self, stmt_handle, schema, array):
        """
        Bind a single batch of values to a prepared statement.
        Corresponds to AdbcStatementBind.
        @param values An Arrow RecordBatch serialized in IPC format.

        Parameters:
         - stmt_handle
         - schema
         - array

        """
        pass

    def statementBindStream(self, stmt_handle, stream):
        """
        Bind a stream of values to a statement (for bulk ingestion).
        Corresponds to AdbcStatementBindStream.
        @param stream An Arrow stream serialized in IPC format.

        Parameters:
         - stmt_handle
         - stream

        """
        pass

    def statementExecuteQuery(self, stmt_handle):
        """
        Execute a query or a statement with bound data.
        Corresponds to AdbcStatementExecuteQuery.
        @return An ExecuteResult struct containing the result stream and rows affected.

        Parameters:
         - stmt_handle

        """
        pass

    def statementExecutePartitions(self, stmt_handle):
        """
        Execute a query and get a description of the result partitions.
        Corresponds to AdbcStatementExecutePartitions.
        @return A PartitionedResult struct containing schema and partition descriptors.

        Parameters:
         - stmt_handle

        """
        pass

    def statementReadPartition(self, stmt_handle, partition_descriptor):
        """
        Read a single partition of a result set.
        Corresponds to AdbcConnectionReadPartition.
        @param partition_descriptor An opaque descriptor from statementExecutePartitions.
        @return An Arrow IPC stream for the requested partition.

        Parameters:
         - stmt_handle
         - partition_descriptor

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def databaseNew(self):
        """
        Create a new, uninitialized database object.
        Corresponds to AdbcDatabaseNew.
        @return An opaque handle to the server-side database object.

        """
        self.send_databaseNew()
        return self.recv_databaseNew()

    def send_databaseNew(self):
        self._oprot.writeMessageBegin('databaseNew', TMessageType.CALL, self._seqid)
        args = databaseNew_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_databaseNew(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = databaseNew_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "databaseNew failed: unknown result")

    def databaseSetOptionString(self, db_handle, key, value):
        """
        Set a string-valued option for a database.
        Corresponds to AdbcDatabaseSetOption.

        Parameters:
         - db_handle
         - key
         - value

        """
        self.send_databaseSetOptionString(db_handle, key, value)
        self.recv_databaseSetOptionString()

    def send_databaseSetOptionString(self, db_handle, key, value):
        self._oprot.writeMessageBegin('databaseSetOptionString', TMessageType.CALL, self._seqid)
        args = databaseSetOptionString_args()
        args.db_handle = db_handle
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_databaseSetOptionString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = databaseSetOptionString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def databaseSetOptionBytes(self, db_handle, key, value):
        """
        Set a byte-valued option for a database.
        Corresponds to AdbcDatabaseSetOptionBytes.

        Parameters:
         - db_handle
         - key
         - value

        """
        self.send_databaseSetOptionBytes(db_handle, key, value)
        self.recv_databaseSetOptionBytes()

    def send_databaseSetOptionBytes(self, db_handle, key, value):
        self._oprot.writeMessageBegin('databaseSetOptionBytes', TMessageType.CALL, self._seqid)
        args = databaseSetOptionBytes_args()
        args.db_handle = db_handle
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_databaseSetOptionBytes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = databaseSetOptionBytes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def databaseSetOptionInt(self, db_handle, key, value):
        """
        Set an integer-valued option for a database.
        Corresponds to AdbcDatabaseSetOptionInt.

        Parameters:
         - db_handle
         - key
         - value

        """
        self.send_databaseSetOptionInt(db_handle, key, value)
        self.recv_databaseSetOptionInt()

    def send_databaseSetOptionInt(self, db_handle, key, value):
        self._oprot.writeMessageBegin('databaseSetOptionInt', TMessageType.CALL, self._seqid)
        args = databaseSetOptionInt_args()
        args.db_handle = db_handle
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_databaseSetOptionInt(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = databaseSetOptionInt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def databaseSetOptionDouble(self, db_handle, key, value):
        """
        Set a double-valued option for a database.
        Corresponds to AdbcDatabaseSetOptionDouble.

        Parameters:
         - db_handle
         - key
         - value

        """
        self.send_databaseSetOptionDouble(db_handle, key, value)
        self.recv_databaseSetOptionDouble()

    def send_databaseSetOptionDouble(self, db_handle, key, value):
        self._oprot.writeMessageBegin('databaseSetOptionDouble', TMessageType.CALL, self._seqid)
        args = databaseSetOptionDouble_args()
        args.db_handle = db_handle
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_databaseSetOptionDouble(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = databaseSetOptionDouble_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def databaseInit(self, db_handle):
        """
        Finalize database initialization.
        Corresponds to AdbcDatabaseInit.

        Parameters:
         - db_handle

        """
        self.send_databaseInit(db_handle)
        self.recv_databaseInit()

    def send_databaseInit(self, db_handle):
        self._oprot.writeMessageBegin('databaseInit', TMessageType.CALL, self._seqid)
        args = databaseInit_args()
        args.db_handle = db_handle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_databaseInit(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = databaseInit_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def databaseRelease(self, db_handle):
        """
        Release the database object and its resources. The handle is invalidated.
        Corresponds to AdbcDatabaseRelease.

        Parameters:
         - db_handle

        """
        self.send_databaseRelease(db_handle)
        self.recv_databaseRelease()

    def send_databaseRelease(self, db_handle):
        self._oprot.writeMessageBegin('databaseRelease', TMessageType.CALL, self._seqid)
        args = databaseRelease_args()
        args.db_handle = db_handle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_databaseRelease(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = databaseRelease_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def connectionNew(self):
        """
        Create a new, uninitialized connection object.
        Corresponds to AdbcConnectionNew.
        @return An opaque handle to the server-side connection object.

        """
        self.send_connectionNew()
        return self.recv_connectionNew()

    def send_connectionNew(self):
        self._oprot.writeMessageBegin('connectionNew', TMessageType.CALL, self._seqid)
        args = connectionNew_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_connectionNew(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = connectionNew_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "connectionNew failed: unknown result")

    def connectionSetOptionString(self, conn_handle, key, value):
        """
        Set a string-valued option for a connection.
        Corresponds to AdbcConnectionSetOption.

        Parameters:
         - conn_handle
         - key
         - value

        """
        self.send_connectionSetOptionString(conn_handle, key, value)
        self.recv_connectionSetOptionString()

    def send_connectionSetOptionString(self, conn_handle, key, value):
        self._oprot.writeMessageBegin('connectionSetOptionString', TMessageType.CALL, self._seqid)
        args = connectionSetOptionString_args()
        args.conn_handle = conn_handle
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_connectionSetOptionString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = connectionSetOptionString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def connectionSetOptionBytes(self, conn_handle, key, value):
        """
        Set a byte-valued option for a connection.
        Corresponds to AdbcConnectionSetOptionBytes.

        Parameters:
         - conn_handle
         - key
         - value

        """
        self.send_connectionSetOptionBytes(conn_handle, key, value)
        self.recv_connectionSetOptionBytes()

    def send_connectionSetOptionBytes(self, conn_handle, key, value):
        self._oprot.writeMessageBegin('connectionSetOptionBytes', TMessageType.CALL, self._seqid)
        args = connectionSetOptionBytes_args()
        args.conn_handle = conn_handle
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_connectionSetOptionBytes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = connectionSetOptionBytes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def connectionSetOptionInt(self, conn_handle, key, value):
        """
        Set an integer-valued option for a connection.
        Corresponds to AdbcConnectionSetOptionInt.

        Parameters:
         - conn_handle
         - key
         - value

        """
        self.send_connectionSetOptionInt(conn_handle, key, value)
        self.recv_connectionSetOptionInt()

    def send_connectionSetOptionInt(self, conn_handle, key, value):
        self._oprot.writeMessageBegin('connectionSetOptionInt', TMessageType.CALL, self._seqid)
        args = connectionSetOptionInt_args()
        args.conn_handle = conn_handle
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_connectionSetOptionInt(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = connectionSetOptionInt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def connectionSetOptionDouble(self, conn_handle, key, value):
        """
        Set a double-valued option for a connection.
        Corresponds to AdbcConnectionSetOptionDouble.

        Parameters:
         - conn_handle
         - key
         - value

        """
        self.send_connectionSetOptionDouble(conn_handle, key, value)
        self.recv_connectionSetOptionDouble()

    def send_connectionSetOptionDouble(self, conn_handle, key, value):
        self._oprot.writeMessageBegin('connectionSetOptionDouble', TMessageType.CALL, self._seqid)
        args = connectionSetOptionDouble_args()
        args.conn_handle = conn_handle
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_connectionSetOptionDouble(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = connectionSetOptionDouble_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def connectionInit(self, conn_handle, db_handle):
        """
        Finalize connection initialization.
        Corresponds to AdbcConnectionInit.

        Parameters:
         - conn_handle
         - db_handle

        """
        self.send_connectionInit(conn_handle, db_handle)
        self.recv_connectionInit()

    def send_connectionInit(self, conn_handle, db_handle):
        self._oprot.writeMessageBegin('connectionInit', TMessageType.CALL, self._seqid)
        args = connectionInit_args()
        args.conn_handle = conn_handle
        args.db_handle = db_handle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_connectionInit(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = connectionInit_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def connectionRelease(self, conn_handle):
        """
        Release the connection object and its resources. The handle is invalidated.
        Corresponds to AdbcConnectionRelease.

        Parameters:
         - conn_handle

        """
        self.send_connectionRelease(conn_handle)
        self.recv_connectionRelease()

    def send_connectionRelease(self, conn_handle):
        self._oprot.writeMessageBegin('connectionRelease', TMessageType.CALL, self._seqid)
        args = connectionRelease_args()
        args.conn_handle = conn_handle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_connectionRelease(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = connectionRelease_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def connectionGetInfo(self, conn_handle, info_codes):
        """
        Get metadata about the database/driver.
        Corresponds to AdbcConnectionGetInfo.
        @param info_codes A list of codes for the metadata to retrieve. If null/empty, retrieve all.
        @return An Arrow IPC stream containing the metadata.

        Parameters:
         - conn_handle
         - info_codes

        """
        self.send_connectionGetInfo(conn_handle, info_codes)
        return self.recv_connectionGetInfo()

    def send_connectionGetInfo(self, conn_handle, info_codes):
        self._oprot.writeMessageBegin('connectionGetInfo', TMessageType.CALL, self._seqid)
        args = connectionGetInfo_args()
        args.conn_handle = conn_handle
        args.info_codes = info_codes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_connectionGetInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = connectionGetInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "connectionGetInfo failed: unknown result")

    def connectionGetObjects(self, conn_handle, depth, catalog, db_schema, table_name, table_type, column_name):
        """
        Get a hierarchical view of catalogs, DB schemas, tables, and columns.
        Corresponds to AdbcConnectionGetObjects.
        @return An Arrow IPC stream containing the metadata.

        Parameters:
         - conn_handle
         - depth
         - catalog
         - db_schema
         - table_name
         - table_type
         - column_name

        """
        self.send_connectionGetObjects(conn_handle, depth, catalog, db_schema, table_name, table_type, column_name)
        return self.recv_connectionGetObjects()

    def send_connectionGetObjects(self, conn_handle, depth, catalog, db_schema, table_name, table_type, column_name):
        self._oprot.writeMessageBegin('connectionGetObjects', TMessageType.CALL, self._seqid)
        args = connectionGetObjects_args()
        args.conn_handle = conn_handle
        args.depth = depth
        args.catalog = catalog
        args.db_schema = db_schema
        args.table_name = table_name
        args.table_type = table_type
        args.column_name = column_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_connectionGetObjects(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = connectionGetObjects_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "connectionGetObjects failed: unknown result")

    def connectionGetTableSchema(self, conn_handle, catalog, db_schema, table_name):
        """
        Get the Arrow schema of a table.
        Corresponds to AdbcConnectionGetTableSchema.
        @return A serialized ArrowSchema in IPC format.

        Parameters:
         - conn_handle
         - catalog
         - db_schema
         - table_name

        """
        self.send_connectionGetTableSchema(conn_handle, catalog, db_schema, table_name)
        return self.recv_connectionGetTableSchema()

    def send_connectionGetTableSchema(self, conn_handle, catalog, db_schema, table_name):
        self._oprot.writeMessageBegin('connectionGetTableSchema', TMessageType.CALL, self._seqid)
        args = connectionGetTableSchema_args()
        args.conn_handle = conn_handle
        args.catalog = catalog
        args.db_schema = db_schema
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_connectionGetTableSchema(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = connectionGetTableSchema_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "connectionGetTableSchema failed: unknown result")

    def connectionGetTableTypes(self, conn_handle):
        """
        Get a list of table types in the database.
        Corresponds to AdbcConnectionGetTableTypes.
        @return An Arrow IPC stream containing the table types.

        Parameters:
         - conn_handle

        """
        self.send_connectionGetTableTypes(conn_handle)
        return self.recv_connectionGetTableTypes()

    def send_connectionGetTableTypes(self, conn_handle):
        self._oprot.writeMessageBegin('connectionGetTableTypes', TMessageType.CALL, self._seqid)
        args = connectionGetTableTypes_args()
        args.conn_handle = conn_handle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_connectionGetTableTypes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = connectionGetTableTypes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "connectionGetTableTypes failed: unknown result")

    def connectionCommit(self, conn_handle):
        """
        Commit any pending transactions.
        Corresponds to AdbcConnectionCommit.

        Parameters:
         - conn_handle

        """
        self.send_connectionCommit(conn_handle)
        self.recv_connectionCommit()

    def send_connectionCommit(self, conn_handle):
        self._oprot.writeMessageBegin('connectionCommit', TMessageType.CALL, self._seqid)
        args = connectionCommit_args()
        args.conn_handle = conn_handle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_connectionCommit(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = connectionCommit_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def connectionRollback(self, conn_handle):
        """
        Roll back any pending transactions.
        Corresponds to AdbcConnectionRollback.

        Parameters:
         - conn_handle

        """
        self.send_connectionRollback(conn_handle)
        self.recv_connectionRollback()

    def send_connectionRollback(self, conn_handle):
        self._oprot.writeMessageBegin('connectionRollback', TMessageType.CALL, self._seqid)
        args = connectionRollback_args()
        args.conn_handle = conn_handle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_connectionRollback(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = connectionRollback_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def statementNew(self, conn_handle):
        """
        Create a new statement.
        Corresponds to AdbcStatementNew.
        @return An opaque handle to the server-side statement object.

        Parameters:
         - conn_handle

        """
        self.send_statementNew(conn_handle)
        return self.recv_statementNew()

    def send_statementNew(self, conn_handle):
        self._oprot.writeMessageBegin('statementNew', TMessageType.CALL, self._seqid)
        args = statementNew_args()
        args.conn_handle = conn_handle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_statementNew(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = statementNew_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "statementNew failed: unknown result")

    def statementRelease(self, stmt_handle):
        """
        Release the statement object.
        Corresponds to AdbcStatementRelease.

        Parameters:
         - stmt_handle

        """
        self.send_statementRelease(stmt_handle)
        self.recv_statementRelease()

    def send_statementRelease(self, stmt_handle):
        self._oprot.writeMessageBegin('statementRelease', TMessageType.CALL, self._seqid)
        args = statementRelease_args()
        args.stmt_handle = stmt_handle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_statementRelease(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = statementRelease_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def statementSetSqlQuery(self, stmt_handle, query):
        """
        Set the SQL query to execute.
        Corresponds to AdbcStatementSetSqlQuery.

        Parameters:
         - stmt_handle
         - query

        """
        self.send_statementSetSqlQuery(stmt_handle, query)
        self.recv_statementSetSqlQuery()

    def send_statementSetSqlQuery(self, stmt_handle, query):
        self._oprot.writeMessageBegin('statementSetSqlQuery', TMessageType.CALL, self._seqid)
        args = statementSetSqlQuery_args()
        args.stmt_handle = stmt_handle
        args.query = query
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_statementSetSqlQuery(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = statementSetSqlQuery_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def statementSetSubstraitPlan(self, stmt_handle, plan):
        """
        Set the Substrait plan to execute.
        Corresponds to AdbcStatementSetSubstraitPlan.

        Parameters:
         - stmt_handle
         - plan

        """
        self.send_statementSetSubstraitPlan(stmt_handle, plan)
        self.recv_statementSetSubstraitPlan()

    def send_statementSetSubstraitPlan(self, stmt_handle, plan):
        self._oprot.writeMessageBegin('statementSetSubstraitPlan', TMessageType.CALL, self._seqid)
        args = statementSetSubstraitPlan_args()
        args.stmt_handle = stmt_handle
        args.plan = plan
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_statementSetSubstraitPlan(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = statementSetSubstraitPlan_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def statementPrepare(self, stmt_handle):
        """
        Prepare a statement for execution.
        Corresponds to AdbcStatementPrepare.

        Parameters:
         - stmt_handle

        """
        self.send_statementPrepare(stmt_handle)
        self.recv_statementPrepare()

    def send_statementPrepare(self, stmt_handle):
        self._oprot.writeMessageBegin('statementPrepare', TMessageType.CALL, self._seqid)
        args = statementPrepare_args()
        args.stmt_handle = stmt_handle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_statementPrepare(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = statementPrepare_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def statementSetOptionString(self, stmt_handle, key, value):
        """
        Set a string-valued option for a statement.
        Corresponds to AdbcStatementSetOption.

        Parameters:
         - stmt_handle
         - key
         - value

        """
        self.send_statementSetOptionString(stmt_handle, key, value)
        self.recv_statementSetOptionString()

    def send_statementSetOptionString(self, stmt_handle, key, value):
        self._oprot.writeMessageBegin('statementSetOptionString', TMessageType.CALL, self._seqid)
        args = statementSetOptionString_args()
        args.stmt_handle = stmt_handle
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_statementSetOptionString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = statementSetOptionString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def statementSetOptionBytes(self, stmt_handle, key, value):
        """
        Set a byte-valued option for a statement.
        Corresponds to AdbcStatementSetOptionBytes.

        Parameters:
         - stmt_handle
         - key
         - value

        """
        self.send_statementSetOptionBytes(stmt_handle, key, value)
        self.recv_statementSetOptionBytes()

    def send_statementSetOptionBytes(self, stmt_handle, key, value):
        self._oprot.writeMessageBegin('statementSetOptionBytes', TMessageType.CALL, self._seqid)
        args = statementSetOptionBytes_args()
        args.stmt_handle = stmt_handle
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_statementSetOptionBytes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = statementSetOptionBytes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def statementSetOptionInt(self, stmt_handle, key, value):
        """
        Set an integer-valued option for a statement.
        Corresponds to AdbcStatementSetOptionInt.

        Parameters:
         - stmt_handle
         - key
         - value

        """
        self.send_statementSetOptionInt(stmt_handle, key, value)
        self.recv_statementSetOptionInt()

    def send_statementSetOptionInt(self, stmt_handle, key, value):
        self._oprot.writeMessageBegin('statementSetOptionInt', TMessageType.CALL, self._seqid)
        args = statementSetOptionInt_args()
        args.stmt_handle = stmt_handle
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_statementSetOptionInt(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = statementSetOptionInt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def statementSetOptionDouble(self, stmt_handle, key, value):
        """
        Set a double-valued option for a statement.
        Corresponds to AdbcStatementSetOptionDouble.

        Parameters:
         - stmt_handle
         - key
         - value

        """
        self.send_statementSetOptionDouble(stmt_handle, key, value)
        self.recv_statementSetOptionDouble()

    def send_statementSetOptionDouble(self, stmt_handle, key, value):
        self._oprot.writeMessageBegin('statementSetOptionDouble', TMessageType.CALL, self._seqid)
        args = statementSetOptionDouble_args()
        args.stmt_handle = stmt_handle
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_statementSetOptionDouble(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = statementSetOptionDouble_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def statementGetParameterSchema(self, stmt_handle):
        """
        Get the schema for the parameters of a prepared statement.
        Corresponds to AdbcStatementGetParameterSchema.
        @return A serialized ArrowSchema in IPC format.

        Parameters:
         - stmt_handle

        """
        self.send_statementGetParameterSchema(stmt_handle)
        return self.recv_statementGetParameterSchema()

    def send_statementGetParameterSchema(self, stmt_handle):
        self._oprot.writeMessageBegin('statementGetParameterSchema', TMessageType.CALL, self._seqid)
        args = statementGetParameterSchema_args()
        args.stmt_handle = stmt_handle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_statementGetParameterSchema(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = statementGetParameterSchema_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "statementGetParameterSchema failed: unknown result")

    def statementBind(self, stmt_handle, schema, array):
        """
        Bind a single batch of values to a prepared statement.
        Corresponds to AdbcStatementBind.
        @param values An Arrow RecordBatch serialized in IPC format.

        Parameters:
         - stmt_handle
         - schema
         - array

        """
        self.send_statementBind(stmt_handle, schema, array)
        self.recv_statementBind()

    def send_statementBind(self, stmt_handle, schema, array):
        self._oprot.writeMessageBegin('statementBind', TMessageType.CALL, self._seqid)
        args = statementBind_args()
        args.stmt_handle = stmt_handle
        args.schema = schema
        args.array = array
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_statementBind(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = statementBind_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def statementBindStream(self, stmt_handle, stream):
        """
        Bind a stream of values to a statement (for bulk ingestion).
        Corresponds to AdbcStatementBindStream.
        @param stream An Arrow stream serialized in IPC format.

        Parameters:
         - stmt_handle
         - stream

        """
        self.send_statementBindStream(stmt_handle, stream)
        self.recv_statementBindStream()

    def send_statementBindStream(self, stmt_handle, stream):
        self._oprot.writeMessageBegin('statementBindStream', TMessageType.CALL, self._seqid)
        args = statementBindStream_args()
        args.stmt_handle = stmt_handle
        args.stream = stream
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_statementBindStream(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = statementBindStream_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def statementExecuteQuery(self, stmt_handle):
        """
        Execute a query or a statement with bound data.
        Corresponds to AdbcStatementExecuteQuery.
        @return An ExecuteResult struct containing the result stream and rows affected.

        Parameters:
         - stmt_handle

        """
        self.send_statementExecuteQuery(stmt_handle)
        return self.recv_statementExecuteQuery()

    def send_statementExecuteQuery(self, stmt_handle):
        self._oprot.writeMessageBegin('statementExecuteQuery', TMessageType.CALL, self._seqid)
        args = statementExecuteQuery_args()
        args.stmt_handle = stmt_handle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_statementExecuteQuery(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = statementExecuteQuery_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "statementExecuteQuery failed: unknown result")

    def statementExecutePartitions(self, stmt_handle):
        """
        Execute a query and get a description of the result partitions.
        Corresponds to AdbcStatementExecutePartitions.
        @return A PartitionedResult struct containing schema and partition descriptors.

        Parameters:
         - stmt_handle

        """
        self.send_statementExecutePartitions(stmt_handle)
        return self.recv_statementExecutePartitions()

    def send_statementExecutePartitions(self, stmt_handle):
        self._oprot.writeMessageBegin('statementExecutePartitions', TMessageType.CALL, self._seqid)
        args = statementExecutePartitions_args()
        args.stmt_handle = stmt_handle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_statementExecutePartitions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = statementExecutePartitions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "statementExecutePartitions failed: unknown result")

    def statementReadPartition(self, stmt_handle, partition_descriptor):
        """
        Read a single partition of a result set.
        Corresponds to AdbcConnectionReadPartition.
        @param partition_descriptor An opaque descriptor from statementExecutePartitions.
        @return An Arrow IPC stream for the requested partition.

        Parameters:
         - stmt_handle
         - partition_descriptor

        """
        self.send_statementReadPartition(stmt_handle, partition_descriptor)
        return self.recv_statementReadPartition()

    def send_statementReadPartition(self, stmt_handle, partition_descriptor):
        self._oprot.writeMessageBegin('statementReadPartition', TMessageType.CALL, self._seqid)
        args = statementReadPartition_args()
        args.stmt_handle = stmt_handle
        args.partition_descriptor = partition_descriptor
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_statementReadPartition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = statementReadPartition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "statementReadPartition failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["databaseNew"] = Processor.process_databaseNew
        self._processMap["databaseSetOptionString"] = Processor.process_databaseSetOptionString
        self._processMap["databaseSetOptionBytes"] = Processor.process_databaseSetOptionBytes
        self._processMap["databaseSetOptionInt"] = Processor.process_databaseSetOptionInt
        self._processMap["databaseSetOptionDouble"] = Processor.process_databaseSetOptionDouble
        self._processMap["databaseInit"] = Processor.process_databaseInit
        self._processMap["databaseRelease"] = Processor.process_databaseRelease
        self._processMap["connectionNew"] = Processor.process_connectionNew
        self._processMap["connectionSetOptionString"] = Processor.process_connectionSetOptionString
        self._processMap["connectionSetOptionBytes"] = Processor.process_connectionSetOptionBytes
        self._processMap["connectionSetOptionInt"] = Processor.process_connectionSetOptionInt
        self._processMap["connectionSetOptionDouble"] = Processor.process_connectionSetOptionDouble
        self._processMap["connectionInit"] = Processor.process_connectionInit
        self._processMap["connectionRelease"] = Processor.process_connectionRelease
        self._processMap["connectionGetInfo"] = Processor.process_connectionGetInfo
        self._processMap["connectionGetObjects"] = Processor.process_connectionGetObjects
        self._processMap["connectionGetTableSchema"] = Processor.process_connectionGetTableSchema
        self._processMap["connectionGetTableTypes"] = Processor.process_connectionGetTableTypes
        self._processMap["connectionCommit"] = Processor.process_connectionCommit
        self._processMap["connectionRollback"] = Processor.process_connectionRollback
        self._processMap["statementNew"] = Processor.process_statementNew
        self._processMap["statementRelease"] = Processor.process_statementRelease
        self._processMap["statementSetSqlQuery"] = Processor.process_statementSetSqlQuery
        self._processMap["statementSetSubstraitPlan"] = Processor.process_statementSetSubstraitPlan
        self._processMap["statementPrepare"] = Processor.process_statementPrepare
        self._processMap["statementSetOptionString"] = Processor.process_statementSetOptionString
        self._processMap["statementSetOptionBytes"] = Processor.process_statementSetOptionBytes
        self._processMap["statementSetOptionInt"] = Processor.process_statementSetOptionInt
        self._processMap["statementSetOptionDouble"] = Processor.process_statementSetOptionDouble
        self._processMap["statementGetParameterSchema"] = Processor.process_statementGetParameterSchema
        self._processMap["statementBind"] = Processor.process_statementBind
        self._processMap["statementBindStream"] = Processor.process_statementBindStream
        self._processMap["statementExecuteQuery"] = Processor.process_statementExecuteQuery
        self._processMap["statementExecutePartitions"] = Processor.process_statementExecutePartitions
        self._processMap["statementReadPartition"] = Processor.process_statementReadPartition
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_databaseNew(self, seqid, iprot, oprot):
        args = databaseNew_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = databaseNew_result()
        try:
            result.success = self._handler.databaseNew()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("databaseNew", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_databaseSetOptionString(self, seqid, iprot, oprot):
        args = databaseSetOptionString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = databaseSetOptionString_result()
        try:
            self._handler.databaseSetOptionString(args.db_handle, args.key, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("databaseSetOptionString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_databaseSetOptionBytes(self, seqid, iprot, oprot):
        args = databaseSetOptionBytes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = databaseSetOptionBytes_result()
        try:
            self._handler.databaseSetOptionBytes(args.db_handle, args.key, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("databaseSetOptionBytes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_databaseSetOptionInt(self, seqid, iprot, oprot):
        args = databaseSetOptionInt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = databaseSetOptionInt_result()
        try:
            self._handler.databaseSetOptionInt(args.db_handle, args.key, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("databaseSetOptionInt", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_databaseSetOptionDouble(self, seqid, iprot, oprot):
        args = databaseSetOptionDouble_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = databaseSetOptionDouble_result()
        try:
            self._handler.databaseSetOptionDouble(args.db_handle, args.key, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("databaseSetOptionDouble", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_databaseInit(self, seqid, iprot, oprot):
        args = databaseInit_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = databaseInit_result()
        try:
            self._handler.databaseInit(args.db_handle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("databaseInit", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_databaseRelease(self, seqid, iprot, oprot):
        args = databaseRelease_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = databaseRelease_result()
        try:
            self._handler.databaseRelease(args.db_handle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("databaseRelease", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_connectionNew(self, seqid, iprot, oprot):
        args = connectionNew_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = connectionNew_result()
        try:
            result.success = self._handler.connectionNew()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("connectionNew", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_connectionSetOptionString(self, seqid, iprot, oprot):
        args = connectionSetOptionString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = connectionSetOptionString_result()
        try:
            self._handler.connectionSetOptionString(args.conn_handle, args.key, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("connectionSetOptionString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_connectionSetOptionBytes(self, seqid, iprot, oprot):
        args = connectionSetOptionBytes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = connectionSetOptionBytes_result()
        try:
            self._handler.connectionSetOptionBytes(args.conn_handle, args.key, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("connectionSetOptionBytes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_connectionSetOptionInt(self, seqid, iprot, oprot):
        args = connectionSetOptionInt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = connectionSetOptionInt_result()
        try:
            self._handler.connectionSetOptionInt(args.conn_handle, args.key, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("connectionSetOptionInt", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_connectionSetOptionDouble(self, seqid, iprot, oprot):
        args = connectionSetOptionDouble_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = connectionSetOptionDouble_result()
        try:
            self._handler.connectionSetOptionDouble(args.conn_handle, args.key, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("connectionSetOptionDouble", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_connectionInit(self, seqid, iprot, oprot):
        args = connectionInit_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = connectionInit_result()
        try:
            self._handler.connectionInit(args.conn_handle, args.db_handle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("connectionInit", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_connectionRelease(self, seqid, iprot, oprot):
        args = connectionRelease_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = connectionRelease_result()
        try:
            self._handler.connectionRelease(args.conn_handle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("connectionRelease", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_connectionGetInfo(self, seqid, iprot, oprot):
        args = connectionGetInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = connectionGetInfo_result()
        try:
            result.success = self._handler.connectionGetInfo(args.conn_handle, args.info_codes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("connectionGetInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_connectionGetObjects(self, seqid, iprot, oprot):
        args = connectionGetObjects_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = connectionGetObjects_result()
        try:
            result.success = self._handler.connectionGetObjects(args.conn_handle, args.depth, args.catalog, args.db_schema, args.table_name, args.table_type, args.column_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("connectionGetObjects", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_connectionGetTableSchema(self, seqid, iprot, oprot):
        args = connectionGetTableSchema_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = connectionGetTableSchema_result()
        try:
            result.success = self._handler.connectionGetTableSchema(args.conn_handle, args.catalog, args.db_schema, args.table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("connectionGetTableSchema", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_connectionGetTableTypes(self, seqid, iprot, oprot):
        args = connectionGetTableTypes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = connectionGetTableTypes_result()
        try:
            result.success = self._handler.connectionGetTableTypes(args.conn_handle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("connectionGetTableTypes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_connectionCommit(self, seqid, iprot, oprot):
        args = connectionCommit_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = connectionCommit_result()
        try:
            self._handler.connectionCommit(args.conn_handle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("connectionCommit", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_connectionRollback(self, seqid, iprot, oprot):
        args = connectionRollback_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = connectionRollback_result()
        try:
            self._handler.connectionRollback(args.conn_handle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("connectionRollback", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_statementNew(self, seqid, iprot, oprot):
        args = statementNew_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = statementNew_result()
        try:
            result.success = self._handler.statementNew(args.conn_handle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("statementNew", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_statementRelease(self, seqid, iprot, oprot):
        args = statementRelease_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = statementRelease_result()
        try:
            self._handler.statementRelease(args.stmt_handle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("statementRelease", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_statementSetSqlQuery(self, seqid, iprot, oprot):
        args = statementSetSqlQuery_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = statementSetSqlQuery_result()
        try:
            self._handler.statementSetSqlQuery(args.stmt_handle, args.query)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("statementSetSqlQuery", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_statementSetSubstraitPlan(self, seqid, iprot, oprot):
        args = statementSetSubstraitPlan_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = statementSetSubstraitPlan_result()
        try:
            self._handler.statementSetSubstraitPlan(args.stmt_handle, args.plan)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("statementSetSubstraitPlan", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_statementPrepare(self, seqid, iprot, oprot):
        args = statementPrepare_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = statementPrepare_result()
        try:
            self._handler.statementPrepare(args.stmt_handle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("statementPrepare", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_statementSetOptionString(self, seqid, iprot, oprot):
        args = statementSetOptionString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = statementSetOptionString_result()
        try:
            self._handler.statementSetOptionString(args.stmt_handle, args.key, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("statementSetOptionString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_statementSetOptionBytes(self, seqid, iprot, oprot):
        args = statementSetOptionBytes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = statementSetOptionBytes_result()
        try:
            self._handler.statementSetOptionBytes(args.stmt_handle, args.key, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("statementSetOptionBytes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_statementSetOptionInt(self, seqid, iprot, oprot):
        args = statementSetOptionInt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = statementSetOptionInt_result()
        try:
            self._handler.statementSetOptionInt(args.stmt_handle, args.key, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("statementSetOptionInt", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_statementSetOptionDouble(self, seqid, iprot, oprot):
        args = statementSetOptionDouble_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = statementSetOptionDouble_result()
        try:
            self._handler.statementSetOptionDouble(args.stmt_handle, args.key, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("statementSetOptionDouble", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_statementGetParameterSchema(self, seqid, iprot, oprot):
        args = statementGetParameterSchema_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = statementGetParameterSchema_result()
        try:
            result.success = self._handler.statementGetParameterSchema(args.stmt_handle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("statementGetParameterSchema", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_statementBind(self, seqid, iprot, oprot):
        args = statementBind_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = statementBind_result()
        try:
            self._handler.statementBind(args.stmt_handle, args.schema, args.array)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("statementBind", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_statementBindStream(self, seqid, iprot, oprot):
        args = statementBindStream_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = statementBindStream_result()
        try:
            self._handler.statementBindStream(args.stmt_handle, args.stream)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("statementBindStream", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_statementExecuteQuery(self, seqid, iprot, oprot):
        args = statementExecuteQuery_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = statementExecuteQuery_result()
        try:
            result.success = self._handler.statementExecuteQuery(args.stmt_handle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("statementExecuteQuery", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_statementExecutePartitions(self, seqid, iprot, oprot):
        args = statementExecutePartitions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = statementExecutePartitions_result()
        try:
            result.success = self._handler.statementExecutePartitions(args.stmt_handle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("statementExecutePartitions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_statementReadPartition(self, seqid, iprot, oprot):
        args = statementReadPartition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = statementReadPartition_result()
        try:
            result.success = self._handler.statementReadPartition(args.stmt_handle, args.partition_descriptor)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DriverException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("statementReadPartition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class databaseNew_args(object):
    thrift_spec = None


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('databaseNew_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(databaseNew_args)
databaseNew_args.thrift_spec = (
)


class databaseNew_result(object):
    """
    Attributes:
     - success
     - e

    """
    thrift_spec = None


    def __init__(self, success = None, e = None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = DatabaseHandle()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('databaseNew_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(databaseNew_result)
databaseNew_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [DatabaseHandle, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class databaseSetOptionString_args(object):
    """
    Attributes:
     - db_handle
     - key
     - value

    """
    thrift_spec = None


    def __init__(self, db_handle = None, key = None, value = None,):
        self.db_handle = db_handle
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.db_handle = DatabaseHandle()
                    self.db_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('databaseSetOptionString_args')
        if self.db_handle is not None:
            oprot.writeFieldBegin('db_handle', TType.STRUCT, 1)
            self.db_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(databaseSetOptionString_args)
databaseSetOptionString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'db_handle', [DatabaseHandle, None], None, ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
)


class databaseSetOptionString_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('databaseSetOptionString_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(databaseSetOptionString_result)
databaseSetOptionString_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class databaseSetOptionBytes_args(object):
    """
    Attributes:
     - db_handle
     - key
     - value

    """
    thrift_spec = None


    def __init__(self, db_handle = None, key = None, value = None,):
        self.db_handle = db_handle
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.db_handle = DatabaseHandle()
                    self.db_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('databaseSetOptionBytes_args')
        if self.db_handle is not None:
            oprot.writeFieldBegin('db_handle', TType.STRUCT, 1)
            self.db_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeBinary(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(databaseSetOptionBytes_args)
databaseSetOptionBytes_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'db_handle', [DatabaseHandle, None], None, ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'BINARY', None, ),  # 3
)


class databaseSetOptionBytes_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('databaseSetOptionBytes_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(databaseSetOptionBytes_result)
databaseSetOptionBytes_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class databaseSetOptionInt_args(object):
    """
    Attributes:
     - db_handle
     - key
     - value

    """
    thrift_spec = None


    def __init__(self, db_handle = None, key = None, value = None,):
        self.db_handle = db_handle
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.db_handle = DatabaseHandle()
                    self.db_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('databaseSetOptionInt_args')
        if self.db_handle is not None:
            oprot.writeFieldBegin('db_handle', TType.STRUCT, 1)
            self.db_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I64, 3)
            oprot.writeI64(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(databaseSetOptionInt_args)
databaseSetOptionInt_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'db_handle', [DatabaseHandle, None], None, ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.I64, 'value', None, None, ),  # 3
)


class databaseSetOptionInt_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('databaseSetOptionInt_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(databaseSetOptionInt_result)
databaseSetOptionInt_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class databaseSetOptionDouble_args(object):
    """
    Attributes:
     - db_handle
     - key
     - value

    """
    thrift_spec = None


    def __init__(self, db_handle = None, key = None, value = None,):
        self.db_handle = db_handle
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.db_handle = DatabaseHandle()
                    self.db_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('databaseSetOptionDouble_args')
        if self.db_handle is not None:
            oprot.writeFieldBegin('db_handle', TType.STRUCT, 1)
            self.db_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.DOUBLE, 3)
            oprot.writeDouble(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(databaseSetOptionDouble_args)
databaseSetOptionDouble_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'db_handle', [DatabaseHandle, None], None, ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.DOUBLE, 'value', None, None, ),  # 3
)


class databaseSetOptionDouble_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('databaseSetOptionDouble_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(databaseSetOptionDouble_result)
databaseSetOptionDouble_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class databaseInit_args(object):
    """
    Attributes:
     - db_handle

    """
    thrift_spec = None


    def __init__(self, db_handle = None,):
        self.db_handle = db_handle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.db_handle = DatabaseHandle()
                    self.db_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('databaseInit_args')
        if self.db_handle is not None:
            oprot.writeFieldBegin('db_handle', TType.STRUCT, 1)
            self.db_handle.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(databaseInit_args)
databaseInit_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'db_handle', [DatabaseHandle, None], None, ),  # 1
)


class databaseInit_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('databaseInit_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(databaseInit_result)
databaseInit_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class databaseRelease_args(object):
    """
    Attributes:
     - db_handle

    """
    thrift_spec = None


    def __init__(self, db_handle = None,):
        self.db_handle = db_handle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.db_handle = DatabaseHandle()
                    self.db_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('databaseRelease_args')
        if self.db_handle is not None:
            oprot.writeFieldBegin('db_handle', TType.STRUCT, 1)
            self.db_handle.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(databaseRelease_args)
databaseRelease_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'db_handle', [DatabaseHandle, None], None, ),  # 1
)


class databaseRelease_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('databaseRelease_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(databaseRelease_result)
databaseRelease_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class connectionNew_args(object):
    thrift_spec = None


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionNew_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionNew_args)
connectionNew_args.thrift_spec = (
)


class connectionNew_result(object):
    """
    Attributes:
     - success
     - e

    """
    thrift_spec = None


    def __init__(self, success = None, e = None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ConnectionHandle()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionNew_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionNew_result)
connectionNew_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ConnectionHandle, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class connectionSetOptionString_args(object):
    """
    Attributes:
     - conn_handle
     - key
     - value

    """
    thrift_spec = None


    def __init__(self, conn_handle = None, key = None, value = None,):
        self.conn_handle = conn_handle
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.conn_handle = ConnectionHandle()
                    self.conn_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionSetOptionString_args')
        if self.conn_handle is not None:
            oprot.writeFieldBegin('conn_handle', TType.STRUCT, 1)
            self.conn_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionSetOptionString_args)
connectionSetOptionString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'conn_handle', [ConnectionHandle, None], None, ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
)


class connectionSetOptionString_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionSetOptionString_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionSetOptionString_result)
connectionSetOptionString_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class connectionSetOptionBytes_args(object):
    """
    Attributes:
     - conn_handle
     - key
     - value

    """
    thrift_spec = None


    def __init__(self, conn_handle = None, key = None, value = None,):
        self.conn_handle = conn_handle
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.conn_handle = ConnectionHandle()
                    self.conn_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionSetOptionBytes_args')
        if self.conn_handle is not None:
            oprot.writeFieldBegin('conn_handle', TType.STRUCT, 1)
            self.conn_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeBinary(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionSetOptionBytes_args)
connectionSetOptionBytes_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'conn_handle', [ConnectionHandle, None], None, ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'BINARY', None, ),  # 3
)


class connectionSetOptionBytes_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionSetOptionBytes_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionSetOptionBytes_result)
connectionSetOptionBytes_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class connectionSetOptionInt_args(object):
    """
    Attributes:
     - conn_handle
     - key
     - value

    """
    thrift_spec = None


    def __init__(self, conn_handle = None, key = None, value = None,):
        self.conn_handle = conn_handle
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.conn_handle = ConnectionHandle()
                    self.conn_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionSetOptionInt_args')
        if self.conn_handle is not None:
            oprot.writeFieldBegin('conn_handle', TType.STRUCT, 1)
            self.conn_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I64, 3)
            oprot.writeI64(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionSetOptionInt_args)
connectionSetOptionInt_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'conn_handle', [ConnectionHandle, None], None, ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.I64, 'value', None, None, ),  # 3
)


class connectionSetOptionInt_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionSetOptionInt_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionSetOptionInt_result)
connectionSetOptionInt_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class connectionSetOptionDouble_args(object):
    """
    Attributes:
     - conn_handle
     - key
     - value

    """
    thrift_spec = None


    def __init__(self, conn_handle = None, key = None, value = None,):
        self.conn_handle = conn_handle
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.conn_handle = ConnectionHandle()
                    self.conn_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionSetOptionDouble_args')
        if self.conn_handle is not None:
            oprot.writeFieldBegin('conn_handle', TType.STRUCT, 1)
            self.conn_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.DOUBLE, 3)
            oprot.writeDouble(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionSetOptionDouble_args)
connectionSetOptionDouble_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'conn_handle', [ConnectionHandle, None], None, ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.DOUBLE, 'value', None, None, ),  # 3
)


class connectionSetOptionDouble_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionSetOptionDouble_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionSetOptionDouble_result)
connectionSetOptionDouble_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class connectionInit_args(object):
    """
    Attributes:
     - conn_handle
     - db_handle

    """
    thrift_spec = None


    def __init__(self, conn_handle = None, db_handle = None,):
        self.conn_handle = conn_handle
        self.db_handle = db_handle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.conn_handle = ConnectionHandle()
                    self.conn_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.db_handle = DatabaseHandle()
                    self.db_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionInit_args')
        if self.conn_handle is not None:
            oprot.writeFieldBegin('conn_handle', TType.STRUCT, 1)
            self.conn_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.db_handle is not None:
            oprot.writeFieldBegin('db_handle', TType.STRUCT, 2)
            self.db_handle.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionInit_args)
connectionInit_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'conn_handle', [ConnectionHandle, None], None, ),  # 1
    (2, TType.STRUCT, 'db_handle', [DatabaseHandle, None], None, ),  # 2
)


class connectionInit_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionInit_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionInit_result)
connectionInit_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class connectionRelease_args(object):
    """
    Attributes:
     - conn_handle

    """
    thrift_spec = None


    def __init__(self, conn_handle = None,):
        self.conn_handle = conn_handle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.conn_handle = ConnectionHandle()
                    self.conn_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionRelease_args')
        if self.conn_handle is not None:
            oprot.writeFieldBegin('conn_handle', TType.STRUCT, 1)
            self.conn_handle.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionRelease_args)
connectionRelease_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'conn_handle', [ConnectionHandle, None], None, ),  # 1
)


class connectionRelease_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionRelease_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionRelease_result)
connectionRelease_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class connectionGetInfo_args(object):
    """
    Attributes:
     - conn_handle
     - info_codes

    """
    thrift_spec = None


    def __init__(self, conn_handle = None, info_codes = None,):
        self.conn_handle = conn_handle
        self.info_codes = info_codes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.conn_handle = ConnectionHandle()
                    self.conn_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.info_codes = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readI32()
                        self.info_codes.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionGetInfo_args')
        if self.conn_handle is not None:
            oprot.writeFieldBegin('conn_handle', TType.STRUCT, 1)
            self.conn_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.info_codes is not None:
            oprot.writeFieldBegin('info_codes', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.info_codes))
            for iter13 in self.info_codes:
                oprot.writeI32(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionGetInfo_args)
connectionGetInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'conn_handle', [ConnectionHandle, None], None, ),  # 1
    (2, TType.LIST, 'info_codes', (TType.I32, None, False), None, ),  # 2
)


class connectionGetInfo_result(object):
    """
    Attributes:
     - success
     - e

    """
    thrift_spec = None


    def __init__(self, success = None, e = None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionGetInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionGetInfo_result)
connectionGetInfo_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class connectionGetObjects_args(object):
    """
    Attributes:
     - conn_handle
     - depth
     - catalog
     - db_schema
     - table_name
     - table_type
     - column_name

    """
    thrift_spec = None


    def __init__(self, conn_handle = None, depth = None, catalog = None, db_schema = None, table_name = None, table_type = None, column_name = None,):
        self.conn_handle = conn_handle
        self.depth = depth
        self.catalog = catalog
        self.db_schema = db_schema
        self.table_name = table_name
        self.table_type = table_type
        self.column_name = column_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.conn_handle = ConnectionHandle()
                    self.conn_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.depth = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.catalog = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.db_schema = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.table_type = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.table_type.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.column_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionGetObjects_args')
        if self.conn_handle is not None:
            oprot.writeFieldBegin('conn_handle', TType.STRUCT, 1)
            self.conn_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.depth is not None:
            oprot.writeFieldBegin('depth', TType.I32, 2)
            oprot.writeI32(self.depth)
            oprot.writeFieldEnd()
        if self.catalog is not None:
            oprot.writeFieldBegin('catalog', TType.STRING, 3)
            oprot.writeString(self.catalog.encode('utf-8') if sys.version_info[0] == 2 else self.catalog)
            oprot.writeFieldEnd()
        if self.db_schema is not None:
            oprot.writeFieldBegin('db_schema', TType.STRING, 4)
            oprot.writeString(self.db_schema.encode('utf-8') if sys.version_info[0] == 2 else self.db_schema)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 5)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.table_type is not None:
            oprot.writeFieldBegin('table_type', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.table_type))
            for iter20 in self.table_type:
                oprot.writeString(iter20.encode('utf-8') if sys.version_info[0] == 2 else iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.column_name is not None:
            oprot.writeFieldBegin('column_name', TType.STRING, 7)
            oprot.writeString(self.column_name.encode('utf-8') if sys.version_info[0] == 2 else self.column_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionGetObjects_args)
connectionGetObjects_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'conn_handle', [ConnectionHandle, None], None, ),  # 1
    (2, TType.I32, 'depth', None, None, ),  # 2
    (3, TType.STRING, 'catalog', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'db_schema', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'table_name', 'UTF8', None, ),  # 5
    (6, TType.LIST, 'table_type', (TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.STRING, 'column_name', 'UTF8', None, ),  # 7
)


class connectionGetObjects_result(object):
    """
    Attributes:
     - success
     - e

    """
    thrift_spec = None


    def __init__(self, success = None, e = None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionGetObjects_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionGetObjects_result)
connectionGetObjects_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class connectionGetTableSchema_args(object):
    """
    Attributes:
     - conn_handle
     - catalog
     - db_schema
     - table_name

    """
    thrift_spec = None


    def __init__(self, conn_handle = None, catalog = None, db_schema = None, table_name = None,):
        self.conn_handle = conn_handle
        self.catalog = catalog
        self.db_schema = db_schema
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.conn_handle = ConnectionHandle()
                    self.conn_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.catalog = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.db_schema = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionGetTableSchema_args')
        if self.conn_handle is not None:
            oprot.writeFieldBegin('conn_handle', TType.STRUCT, 1)
            self.conn_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.catalog is not None:
            oprot.writeFieldBegin('catalog', TType.STRING, 2)
            oprot.writeString(self.catalog.encode('utf-8') if sys.version_info[0] == 2 else self.catalog)
            oprot.writeFieldEnd()
        if self.db_schema is not None:
            oprot.writeFieldBegin('db_schema', TType.STRING, 3)
            oprot.writeString(self.db_schema.encode('utf-8') if sys.version_info[0] == 2 else self.db_schema)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 4)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionGetTableSchema_args)
connectionGetTableSchema_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'conn_handle', [ConnectionHandle, None], None, ),  # 1
    (2, TType.STRING, 'catalog', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'db_schema', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'table_name', 'UTF8', None, ),  # 4
)


class connectionGetTableSchema_result(object):
    """
    Attributes:
     - success
     - e

    """
    thrift_spec = None


    def __init__(self, success = None, e = None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionGetTableSchema_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionGetTableSchema_result)
connectionGetTableSchema_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class connectionGetTableTypes_args(object):
    """
    Attributes:
     - conn_handle

    """
    thrift_spec = None


    def __init__(self, conn_handle = None,):
        self.conn_handle = conn_handle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.conn_handle = ConnectionHandle()
                    self.conn_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionGetTableTypes_args')
        if self.conn_handle is not None:
            oprot.writeFieldBegin('conn_handle', TType.STRUCT, 1)
            self.conn_handle.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionGetTableTypes_args)
connectionGetTableTypes_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'conn_handle', [ConnectionHandle, None], None, ),  # 1
)


class connectionGetTableTypes_result(object):
    """
    Attributes:
     - success
     - e

    """
    thrift_spec = None


    def __init__(self, success = None, e = None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionGetTableTypes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionGetTableTypes_result)
connectionGetTableTypes_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class connectionCommit_args(object):
    """
    Attributes:
     - conn_handle

    """
    thrift_spec = None


    def __init__(self, conn_handle = None,):
        self.conn_handle = conn_handle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.conn_handle = ConnectionHandle()
                    self.conn_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionCommit_args')
        if self.conn_handle is not None:
            oprot.writeFieldBegin('conn_handle', TType.STRUCT, 1)
            self.conn_handle.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionCommit_args)
connectionCommit_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'conn_handle', [ConnectionHandle, None], None, ),  # 1
)


class connectionCommit_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionCommit_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionCommit_result)
connectionCommit_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class connectionRollback_args(object):
    """
    Attributes:
     - conn_handle

    """
    thrift_spec = None


    def __init__(self, conn_handle = None,):
        self.conn_handle = conn_handle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.conn_handle = ConnectionHandle()
                    self.conn_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionRollback_args')
        if self.conn_handle is not None:
            oprot.writeFieldBegin('conn_handle', TType.STRUCT, 1)
            self.conn_handle.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionRollback_args)
connectionRollback_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'conn_handle', [ConnectionHandle, None], None, ),  # 1
)


class connectionRollback_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('connectionRollback_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(connectionRollback_result)
connectionRollback_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class statementNew_args(object):
    """
    Attributes:
     - conn_handle

    """
    thrift_spec = None


    def __init__(self, conn_handle = None,):
        self.conn_handle = conn_handle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.conn_handle = ConnectionHandle()
                    self.conn_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementNew_args')
        if self.conn_handle is not None:
            oprot.writeFieldBegin('conn_handle', TType.STRUCT, 1)
            self.conn_handle.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementNew_args)
statementNew_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'conn_handle', [ConnectionHandle, None], None, ),  # 1
)


class statementNew_result(object):
    """
    Attributes:
     - success
     - e

    """
    thrift_spec = None


    def __init__(self, success = None, e = None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = StatementHandle()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementNew_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementNew_result)
statementNew_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [StatementHandle, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class statementRelease_args(object):
    """
    Attributes:
     - stmt_handle

    """
    thrift_spec = None


    def __init__(self, stmt_handle = None,):
        self.stmt_handle = stmt_handle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stmt_handle = StatementHandle()
                    self.stmt_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementRelease_args')
        if self.stmt_handle is not None:
            oprot.writeFieldBegin('stmt_handle', TType.STRUCT, 1)
            self.stmt_handle.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementRelease_args)
statementRelease_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stmt_handle', [StatementHandle, None], None, ),  # 1
)


class statementRelease_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementRelease_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementRelease_result)
statementRelease_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class statementSetSqlQuery_args(object):
    """
    Attributes:
     - stmt_handle
     - query

    """
    thrift_spec = None


    def __init__(self, stmt_handle = None, query = None,):
        self.stmt_handle = stmt_handle
        self.query = query

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stmt_handle = StatementHandle()
                    self.stmt_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.query = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementSetSqlQuery_args')
        if self.stmt_handle is not None:
            oprot.writeFieldBegin('stmt_handle', TType.STRUCT, 1)
            self.stmt_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRING, 2)
            oprot.writeString(self.query.encode('utf-8') if sys.version_info[0] == 2 else self.query)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementSetSqlQuery_args)
statementSetSqlQuery_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stmt_handle', [StatementHandle, None], None, ),  # 1
    (2, TType.STRING, 'query', 'UTF8', None, ),  # 2
)


class statementSetSqlQuery_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementSetSqlQuery_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementSetSqlQuery_result)
statementSetSqlQuery_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class statementSetSubstraitPlan_args(object):
    """
    Attributes:
     - stmt_handle
     - plan

    """
    thrift_spec = None


    def __init__(self, stmt_handle = None, plan = None,):
        self.stmt_handle = stmt_handle
        self.plan = plan

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stmt_handle = StatementHandle()
                    self.stmt_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.plan = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementSetSubstraitPlan_args')
        if self.stmt_handle is not None:
            oprot.writeFieldBegin('stmt_handle', TType.STRUCT, 1)
            self.stmt_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.plan is not None:
            oprot.writeFieldBegin('plan', TType.STRING, 2)
            oprot.writeBinary(self.plan)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementSetSubstraitPlan_args)
statementSetSubstraitPlan_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stmt_handle', [StatementHandle, None], None, ),  # 1
    (2, TType.STRING, 'plan', 'BINARY', None, ),  # 2
)


class statementSetSubstraitPlan_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementSetSubstraitPlan_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementSetSubstraitPlan_result)
statementSetSubstraitPlan_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class statementPrepare_args(object):
    """
    Attributes:
     - stmt_handle

    """
    thrift_spec = None


    def __init__(self, stmt_handle = None,):
        self.stmt_handle = stmt_handle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stmt_handle = StatementHandle()
                    self.stmt_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementPrepare_args')
        if self.stmt_handle is not None:
            oprot.writeFieldBegin('stmt_handle', TType.STRUCT, 1)
            self.stmt_handle.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementPrepare_args)
statementPrepare_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stmt_handle', [StatementHandle, None], None, ),  # 1
)


class statementPrepare_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementPrepare_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementPrepare_result)
statementPrepare_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class statementSetOptionString_args(object):
    """
    Attributes:
     - stmt_handle
     - key
     - value

    """
    thrift_spec = None


    def __init__(self, stmt_handle = None, key = None, value = None,):
        self.stmt_handle = stmt_handle
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stmt_handle = StatementHandle()
                    self.stmt_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementSetOptionString_args')
        if self.stmt_handle is not None:
            oprot.writeFieldBegin('stmt_handle', TType.STRUCT, 1)
            self.stmt_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementSetOptionString_args)
statementSetOptionString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stmt_handle', [StatementHandle, None], None, ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
)


class statementSetOptionString_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementSetOptionString_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementSetOptionString_result)
statementSetOptionString_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class statementSetOptionBytes_args(object):
    """
    Attributes:
     - stmt_handle
     - key
     - value

    """
    thrift_spec = None


    def __init__(self, stmt_handle = None, key = None, value = None,):
        self.stmt_handle = stmt_handle
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stmt_handle = StatementHandle()
                    self.stmt_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementSetOptionBytes_args')
        if self.stmt_handle is not None:
            oprot.writeFieldBegin('stmt_handle', TType.STRUCT, 1)
            self.stmt_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeBinary(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementSetOptionBytes_args)
statementSetOptionBytes_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stmt_handle', [StatementHandle, None], None, ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'BINARY', None, ),  # 3
)


class statementSetOptionBytes_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementSetOptionBytes_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementSetOptionBytes_result)
statementSetOptionBytes_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class statementSetOptionInt_args(object):
    """
    Attributes:
     - stmt_handle
     - key
     - value

    """
    thrift_spec = None


    def __init__(self, stmt_handle = None, key = None, value = None,):
        self.stmt_handle = stmt_handle
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stmt_handle = StatementHandle()
                    self.stmt_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementSetOptionInt_args')
        if self.stmt_handle is not None:
            oprot.writeFieldBegin('stmt_handle', TType.STRUCT, 1)
            self.stmt_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I64, 3)
            oprot.writeI64(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementSetOptionInt_args)
statementSetOptionInt_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stmt_handle', [StatementHandle, None], None, ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.I64, 'value', None, None, ),  # 3
)


class statementSetOptionInt_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementSetOptionInt_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementSetOptionInt_result)
statementSetOptionInt_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class statementSetOptionDouble_args(object):
    """
    Attributes:
     - stmt_handle
     - key
     - value

    """
    thrift_spec = None


    def __init__(self, stmt_handle = None, key = None, value = None,):
        self.stmt_handle = stmt_handle
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stmt_handle = StatementHandle()
                    self.stmt_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementSetOptionDouble_args')
        if self.stmt_handle is not None:
            oprot.writeFieldBegin('stmt_handle', TType.STRUCT, 1)
            self.stmt_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.DOUBLE, 3)
            oprot.writeDouble(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementSetOptionDouble_args)
statementSetOptionDouble_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stmt_handle', [StatementHandle, None], None, ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
    (3, TType.DOUBLE, 'value', None, None, ),  # 3
)


class statementSetOptionDouble_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementSetOptionDouble_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementSetOptionDouble_result)
statementSetOptionDouble_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class statementGetParameterSchema_args(object):
    """
    Attributes:
     - stmt_handle

    """
    thrift_spec = None


    def __init__(self, stmt_handle = None,):
        self.stmt_handle = stmt_handle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stmt_handle = StatementHandle()
                    self.stmt_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementGetParameterSchema_args')
        if self.stmt_handle is not None:
            oprot.writeFieldBegin('stmt_handle', TType.STRUCT, 1)
            self.stmt_handle.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementGetParameterSchema_args)
statementGetParameterSchema_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stmt_handle', [StatementHandle, None], None, ),  # 1
)


class statementGetParameterSchema_result(object):
    """
    Attributes:
     - success
     - e

    """
    thrift_spec = None


    def __init__(self, success = None, e = None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ArrowSchemaPtr()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementGetParameterSchema_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementGetParameterSchema_result)
statementGetParameterSchema_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ArrowSchemaPtr, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class statementBind_args(object):
    """
    Attributes:
     - stmt_handle
     - schema
     - array

    """
    thrift_spec = None


    def __init__(self, stmt_handle = None, schema = None, array = None,):
        self.stmt_handle = stmt_handle
        self.schema = schema
        self.array = array

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stmt_handle = StatementHandle()
                    self.stmt_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.schema = ArrowSchemaPtr()
                    self.schema.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.array = ArrowArrayPtr()
                    self.array.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementBind_args')
        if self.stmt_handle is not None:
            oprot.writeFieldBegin('stmt_handle', TType.STRUCT, 1)
            self.stmt_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.schema is not None:
            oprot.writeFieldBegin('schema', TType.STRUCT, 2)
            self.schema.write(oprot)
            oprot.writeFieldEnd()
        if self.array is not None:
            oprot.writeFieldBegin('array', TType.STRUCT, 3)
            self.array.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementBind_args)
statementBind_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stmt_handle', [StatementHandle, None], None, ),  # 1
    (2, TType.STRUCT, 'schema', [ArrowSchemaPtr, None], None, ),  # 2
    (3, TType.STRUCT, 'array', [ArrowArrayPtr, None], None, ),  # 3
)


class statementBind_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementBind_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementBind_result)
statementBind_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class statementBindStream_args(object):
    """
    Attributes:
     - stmt_handle
     - stream

    """
    thrift_spec = None


    def __init__(self, stmt_handle = None, stream = None,):
        self.stmt_handle = stmt_handle
        self.stream = stream

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stmt_handle = StatementHandle()
                    self.stmt_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.stream = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementBindStream_args')
        if self.stmt_handle is not None:
            oprot.writeFieldBegin('stmt_handle', TType.STRUCT, 1)
            self.stmt_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.stream is not None:
            oprot.writeFieldBegin('stream', TType.STRING, 2)
            oprot.writeBinary(self.stream)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementBindStream_args)
statementBindStream_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stmt_handle', [StatementHandle, None], None, ),  # 1
    (2, TType.STRING, 'stream', 'BINARY', None, ),  # 2
)


class statementBindStream_result(object):
    """
    Attributes:
     - e

    """
    thrift_spec = None


    def __init__(self, e = None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementBindStream_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementBindStream_result)
statementBindStream_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class statementExecuteQuery_args(object):
    """
    Attributes:
     - stmt_handle

    """
    thrift_spec = None


    def __init__(self, stmt_handle = None,):
        self.stmt_handle = stmt_handle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stmt_handle = StatementHandle()
                    self.stmt_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementExecuteQuery_args')
        if self.stmt_handle is not None:
            oprot.writeFieldBegin('stmt_handle', TType.STRUCT, 1)
            self.stmt_handle.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementExecuteQuery_args)
statementExecuteQuery_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stmt_handle', [StatementHandle, None], None, ),  # 1
)


class statementExecuteQuery_result(object):
    """
    Attributes:
     - success
     - e

    """
    thrift_spec = None


    def __init__(self, success = None, e = None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ExecuteResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementExecuteQuery_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementExecuteQuery_result)
statementExecuteQuery_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ExecuteResult, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class statementExecutePartitions_args(object):
    """
    Attributes:
     - stmt_handle

    """
    thrift_spec = None


    def __init__(self, stmt_handle = None,):
        self.stmt_handle = stmt_handle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stmt_handle = StatementHandle()
                    self.stmt_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementExecutePartitions_args')
        if self.stmt_handle is not None:
            oprot.writeFieldBegin('stmt_handle', TType.STRUCT, 1)
            self.stmt_handle.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementExecutePartitions_args)
statementExecutePartitions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stmt_handle', [StatementHandle, None], None, ),  # 1
)


class statementExecutePartitions_result(object):
    """
    Attributes:
     - success
     - e

    """
    thrift_spec = None


    def __init__(self, success = None, e = None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PartitionedResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementExecutePartitions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementExecutePartitions_result)
statementExecutePartitions_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [PartitionedResult, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)


class statementReadPartition_args(object):
    """
    Attributes:
     - stmt_handle
     - partition_descriptor

    """
    thrift_spec = None


    def __init__(self, stmt_handle = None, partition_descriptor = None,):
        self.stmt_handle = stmt_handle
        self.partition_descriptor = partition_descriptor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stmt_handle = StatementHandle()
                    self.stmt_handle.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.partition_descriptor = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementReadPartition_args')
        if self.stmt_handle is not None:
            oprot.writeFieldBegin('stmt_handle', TType.STRUCT, 1)
            self.stmt_handle.write(oprot)
            oprot.writeFieldEnd()
        if self.partition_descriptor is not None:
            oprot.writeFieldBegin('partition_descriptor', TType.STRING, 2)
            oprot.writeBinary(self.partition_descriptor)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementReadPartition_args)
statementReadPartition_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stmt_handle', [StatementHandle, None], None, ),  # 1
    (2, TType.STRING, 'partition_descriptor', 'BINARY', None, ),  # 2
)


class statementReadPartition_result(object):
    """
    Attributes:
     - success
     - e

    """
    thrift_spec = None


    def __init__(self, success = None, e = None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = DriverException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('statementReadPartition_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(statementReadPartition_result)
statementReadPartition_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [DriverException, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs
